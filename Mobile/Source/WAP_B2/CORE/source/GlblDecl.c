/*
 * Copyright (C) Ericsson Mobile Communications AB, 2000.
 * Licensed to AU-System AB.
 * All rights reserved.
 *
 * This software is covered by the license agreement between
 * the end user and AU-System AB, and may be used and copied
 * only in accordance with the terms of the said agreement.
 *
 * Neither Ericsson Mobile Communications AB nor AU-System AB
 * assumes any responsibility or liability for any errors or inaccuracies in
 * this software, or any consequential, incidental or indirect damage arising
 * out of the use of the Generic WAP Client software.
 */

/* Program generated by SDT Cmicro, version 1.33 */

#ifndef XSCT_CMICRO
#define XSCT_CMICRO
#endif

#define C_MICRO_1_3
#include "ml_typ.h"
#include "GlblDecl.h"


/*************************************************************************
**                  #CODE directives, #BODY sections                    **
*************************************************************************/

/*************************************************************************
**                  SECTION Variables and Functions                     **
*************************************************************************/

/*****
* NEWTYPE DeviceAddress  (BODY section)
* <<PACKAGE Global_Declarations>>
* #SDTREF(SDL,D:\WIP\Maintenance\WAP_1.1\System\base_co\sdl\packages\Global_Declarations.sun(1),200(45,45),1)
******/
                /* #SDTREF(SDL,D:\WIP\Maintenance\WAP_1.1\System\base_co\sdl\packages\Global_Declarations.sun(1),200(45,45),10) */
DeviceAddress
devaddr_null (void)
{
  DeviceAddress da;

  da.length = 0;
  return da;
}

SDL_Integer
devaddr_getlen (DeviceAddress *paddr)
{
  return paddr->length;
}

DeviceAddress
devaddr_fromOS (SDL_Octet_String os)
{
  DeviceAddress da;

  da.length = ((os.Length < MAX_DEVICE_ADDR_LEN)?
               os.Length : MAX_DEVICE_ADDR_LEN);
  memcpy (da.data, os.Bits, da.length);

  return da;
}

SDL_Octet_String
devaddr_toOS (DeviceAddress *paddr)
{
  SDL_Octet_String os;

  os.Length = paddr->length;
#ifdef WAPCORE_FOR_WARNING
  os.Bits =(unsigned char *)xAlloc (os.Length);
#else
  os.Bits = xAlloc (os.Length);
#endif //WAPCORE_FOR_WARNING
  memcpy (os.Bits, paddr->data, os.Length);
  os.IsAssigned = 0;
#ifdef XSCT_CMICRO
  os.IsUsedInSignal = 0;
#endif

  return os;
}

void
devaddr_store (DeviceAddress *paddr, BYTE *buf, UINT8 len)
{
  paddr->length = ((len < MAX_DEVICE_ADDR_LEN) ?
                    len : MAX_DEVICE_ADDR_LEN);
  memcpy (paddr->data, buf, paddr->length);
}

void
devaddr_get (DeviceAddress *paddr, BYTE *buf, UINT8 *len)
{
  *len = paddr->length;
  memcpy (buf, paddr->data, paddr->length);
}

void
yDef_DeviceAddress (DeviceAddress *paddr)
{
  paddr->length = 0;
}

SDL_Boolean
yEq_DeviceAddress (DeviceAddress addr1, DeviceAddress addr2)
{
  INT16 i;

  if (addr1.length != addr2.length) {
    return SDL_False;
  }
  for (i = 0; i < addr1.length; i++) {
    if (addr1.data[i] != addr2.data[i]) {
      return SDL_False;
    }
  }

  return SDL_True;
}


/*****
* NEWTYPE AuxiliaryAddress  (BODY section)
* <<PACKAGE Global_Declarations>>
* #SDTREF(SDL,D:\WIP\Maintenance\WAP_1.1\System\base_co\sdl\packages\Global_Declarations.sun(1),203(45,65),1)
******/
                /* #SDTREF(SDL,D:\WIP\Maintenance\WAP_1.1\System\base_co\sdl\packages\Global_Declarations.sun(1),203(45,65),10) */
AuxiliaryAddress
auxaddr_null (void)
{
  AuxiliaryAddress aa;

  aa.length = 0;
  return aa;
}

SDL_Integer
auxaddr_getlen (AuxiliaryAddress *paddr)
{
  return paddr->length;
}

AuxiliaryAddress
auxaddr_fromOS (SDL_Octet_String os)
{
  AuxiliaryAddress aa;

  aa.length = ((os.Length < MAX_AUX_ADDR_LEN) ?
                os.Length : MAX_AUX_ADDR_LEN);
  memcpy (aa.data, os.Bits, aa.length);

  return aa;
}

SDL_Octet_String
auxaddr_toOS (AuxiliaryAddress *paddr)
{
  SDL_Octet_String os;

  os.Length = paddr->length;
#ifdef WAPCORE_FOR_WARNING
  os.Bits = (unsigned char *)xAlloc (os.Length);
#else
  os.Bits = xAlloc (os.Length);
#endif //WAPCORE_FOR_WARNING
  memcpy (os.Bits, paddr->data, os.Length);
  os.IsAssigned = 0;
#ifdef XSCT_CMICRO
  os.IsUsedInSignal = 0;
#endif

  return os;
}

void
auxaddr_store (AuxiliaryAddress *paddr, BYTE *buf, UINT8 len)
{
  paddr->length = ((len < MAX_AUX_ADDR_LEN) ?
                    len : MAX_AUX_ADDR_LEN);
  memcpy (paddr->data, buf, paddr->length);
}

void
auxaddr_get (AuxiliaryAddress *paddr, BYTE *buf, UINT8 *len)
{
  *len = paddr->length;
  memcpy (buf, paddr->data, paddr->length);
}

void
yDef_AuxiliaryAddress (AuxiliaryAddress *paddr)
{
  paddr->length = 0;
}

SDL_Boolean
yEq_AuxiliaryAddress (AuxiliaryAddress addr1, AuxiliaryAddress addr2)
{
  INT16 i;

  if (addr1.length != addr2.length) {
    return SDL_False;
  }
  for (i = 0; i < addr1.length; i++) {
    if (addr1.data[i] != addr2.data[i]) {
      return SDL_False;
    }
  }

  return SDL_True;
}


/*****
* NEWTYPE AddressType  (BODY section)
* <<PACKAGE Global_Declarations>>
* #SDTREF(SDL,D:\WIP\Maintenance\WAP_1.1\System\base_co\sdl\packages\Global_Declarations.sun(1),206(25,90),1)
******/

/*------------------DEFAULT-----------------*/
#ifndef XNOPROTO
extern void yDef_AddressType( AddressType *yVar )
#else
extern void yDef_AddressType( yVar )
  AddressType *yVar;
#endif
{
  xDef_SDL_Octet(&((*yVar).Bearer));
  xDef_SDL_Octet(&((*yVar).SecondAddressFormat));
  xDef_SDL_Integer(&((*yVar).PortNumber));
  yDef_DeviceAddress(&((*yVar).Address));
  yDef_AuxiliaryAddress(&((*yVar).SecondAddress));
}

/*------------------EQUAL-------------------*/
#ifndef XNOPROTO
extern SDL_Boolean yEq_AddressType(
  AddressType yExpr1,
  AddressType yExpr2 )
#else
extern SDL_Boolean yEq_AddressType( yExpr1, yExpr2 )
  AddressType yExpr1, yExpr2;
#endif
{
  if ( yNEqF_SDL_Octet(yExpr1.Bearer, yExpr2.Bearer) ) return SDL_False;
  if ( yNEqF_SDL_Octet(yExpr1.SecondAddressFormat,
  yExpr2.SecondAddressFormat) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.PortNumber, yExpr2.PortNumber) )
  return SDL_False;
  if ( yNEqF_DeviceAddress(yExpr1.Address, yExpr2.Address) ) return SDL_False;
  if ( yNEqF_AuxiliaryAddress(yExpr1.SecondAddress, yExpr2.SecondAddress) )
  return SDL_False;
  return SDL_True;
}

/*-------------------MAKE-------------------*/
#ifndef XNOPROTO
extern AddressType yMake_AddressType(
  SDL_Octet yBearer,
  SDL_Octet ySecondAddressFormat,
  SDL_Integer yPortNumber,
  DeviceAddress yAddress,
  AuxiliaryAddress ySecondAddress )
#else
extern AddressType  yMake_AddressType( yBearer, ySecondAddressFormat,
  yPortNumber, yAddress, ySecondAddress )
  SDL_Octet yBearer;
  SDL_Octet ySecondAddressFormat;
  SDL_Integer yPortNumber;
  DeviceAddress yAddress;
  AuxiliaryAddress ySecondAddress;
#endif
{
  AddressType  yVar;
  memset((void *)(&yVar), 0, sizeof(AddressType));
  yAssF_SDL_Octet(yVar.Bearer, yBearer, XASSMAKE);
  yAssF_SDL_Octet(yVar.SecondAddressFormat, ySecondAddressFormat, XASSMAKE);
  yAssF_SDL_Integer(yVar.PortNumber, yPortNumber, XASSMAKE);
  yAssF_DeviceAddress(yVar.Address, yAddress, XASSMAKE);
  yAssF_AuxiliaryAddress(yVar.SecondAddress, ySecondAddress, XASSMAKE);
  return yVar;
}
