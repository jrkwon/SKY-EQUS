/*
 * Copyright (C) Ericsson Mobile Communications AB, 2001.
 * Licensed to AU-System AB.
 * All rights reserved.
 *
 * This software is covered by the license agreement between
 * the end user and AU-System AB, and may be used and copied
 * only in accordance with the terms of the said agreement.
 *
 * Neither Ericsson Mobile Communications AB nor AU-System AB
 * assumes any responsibility or liability for any errors or inaccuracies in
 * this software, or any consequential, incidental or indirect damage arising
 * out of the use of the Generic WAP Client software.
 */

/* Program generated by SDT Cmicro, version 1.33 */

#ifndef XSCT_CMICRO
#define XSCT_CMICRO
#endif

#define C_MICRO_1_3
#include "ml_typw.h"
#include "ctypes.h"
#include "buffmgt.h"
#include "glbldecl.h"
#include "wspcmwtp.h"


/*************************************************************************
**                  #CODE directives, #BODY sections                    **
*************************************************************************/

/*************************************************************************
**                  SECTION Variables and Functions                     **
*************************************************************************/

/*****
* NEWTYPE TRInvokeReqType  (BODY section)
* <<PACKAGE WSPConnectionMode_WTP>>
* #SDTREF(SDL,D:\WIP\Maintenance\4.x\System\SystemConfigurations\base_push_wta_wtls_co_korea\sdl\packages\wspconnectionmode_wtp.sun(1),164(25,50),3)
******/

/*------------------DEFAULT-----------------*/
#ifndef XNOPROTO
extern void yDef_TRInvokeReqType( TRInvokeReqType *yVar )
#else
extern void yDef_TRInvokeReqType( yVar )
  TRInvokeReqType *yVar;
#endif
{
  yDef_AddressType(&((*yVar).SourceAddress));
  yDef_AddressType(&((*yVar).DestinationAddress));
  xDef_SDL_Integer(&((*yVar).AckType));
  yDef_pdubuf_ptr(&((*yVar).UserData));
  xDef_SDL_Integer(&((*yVar).ClassType));
  xDef_SDL_Integer(&((*yVar).Handle));
  xDef_SDL_Boolean(&((*yVar).AllowSegmentedResult));
  xDef_SDL_Boolean(&((*yVar).MoreData));
  xDef_SDL_Natural(&((*yVar).TotalSize));
}

/*------------------EQUAL-------------------*/
#ifndef XNOPROTO
extern SDL_Boolean yEq_TRInvokeReqType(
  TRInvokeReqType yExpr1,
  TRInvokeReqType yExpr2 )
#else
extern SDL_Boolean yEq_TRInvokeReqType( yExpr1, yExpr2 )
  TRInvokeReqType yExpr1, yExpr2;
#endif
{
  if ( yNEqF_AddressType(yExpr1.SourceAddress, yExpr2.SourceAddress) )
  return SDL_False;
  if ( yNEqF_AddressType(yExpr1.DestinationAddress,
  yExpr2.DestinationAddress) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.AckType, yExpr2.AckType) ) return SDL_False;
  if ( yNEqF_pdubuf_ptr(yExpr1.UserData, yExpr2.UserData) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.ClassType, yExpr2.ClassType) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.Handle, yExpr2.Handle) ) return SDL_False;
  if ( yNEqF_SDL_Boolean(yExpr1.AllowSegmentedResult,
  yExpr2.AllowSegmentedResult) ) return SDL_False;
  if ( yNEqF_SDL_Boolean(yExpr1.MoreData, yExpr2.MoreData) ) return SDL_False;
  if ( yNEqF_SDL_Natural(yExpr1.TotalSize, yExpr2.TotalSize) ) return SDL_False;
  return SDL_True;
}

/*-------------------MAKE-------------------*/
#ifndef XNOPROTO
extern TRInvokeReqType yMake_TRInvokeReqType(
  AddressType ySourceAddress,
  AddressType yDestinationAddress,
  SDL_Integer yAckType,
  pdubuf_ptr yUserData,
  SDL_Integer yClassType,
  SDL_Integer yHandle,
  SDL_Boolean yAllowSegmentedResult,
  SDL_Boolean yMoreData,
  SDL_Natural yTotalSize )
#else
extern TRInvokeReqType  yMake_TRInvokeReqType( ySourceAddress,
  yDestinationAddress, yAckType, yUserData, yClassType, yHandle,
  yAllowSegmentedResult, yMoreData, yTotalSize )
  AddressType ySourceAddress;
  AddressType yDestinationAddress;
  SDL_Integer yAckType;
  pdubuf_ptr yUserData;
  SDL_Integer yClassType;
  SDL_Integer yHandle;
  SDL_Boolean yAllowSegmentedResult;
  SDL_Boolean yMoreData;
  SDL_Natural yTotalSize;
#endif
{
  TRInvokeReqType  yVar;
  memset((void *)(&yVar), 0, sizeof(TRInvokeReqType));
  yAssF_AddressType(yVar.SourceAddress, ySourceAddress, XASSMAKE);
  yAssF_AddressType(yVar.DestinationAddress, yDestinationAddress, XASSMAKE);
  yAssF_SDL_Integer(yVar.AckType, yAckType, XASSMAKE);
  yAssF_pdubuf_ptr(yVar.UserData, yUserData, XASSMAKE);
  yAssF_SDL_Integer(yVar.ClassType, yClassType, XASSMAKE);
  yAssF_SDL_Integer(yVar.Handle, yHandle, XASSMAKE);
  yAssF_SDL_Boolean(yVar.AllowSegmentedResult, yAllowSegmentedResult, XASSMAKE);
  yAssF_SDL_Boolean(yVar.MoreData, yMoreData, XASSMAKE);
  yAssF_SDL_Natural(yVar.TotalSize, yTotalSize, XASSMAKE);
  return yVar;
}

/*****
* NEWTYPE TRInvokeIndType  (BODY section)
* <<PACKAGE WSPConnectionMode_WTP>>
* #SDTREF(SDL,D:\WIP\Maintenance\4.x\System\SystemConfigurations\base_push_wta_wtls_co_korea\sdl\packages\wspconnectionmode_wtp.sun(1),164(25,50),15)
******/

/*------------------DEFAULT-----------------*/
#ifndef XNOPROTO
extern void yDef_TRInvokeIndType( TRInvokeIndType *yVar )
#else
extern void yDef_TRInvokeIndType( yVar )
  TRInvokeIndType *yVar;
#endif
{
  yDef_AddressType(&((*yVar).SourceAddress));
  yDef_AddressType(&((*yVar).DestinationAddress));
  xDef_SDL_Integer(&((*yVar).AckType));
  yDef_pdubuf_ptr(&((*yVar).UserData));
  xDef_SDL_Integer(&((*yVar).ClassType));
  xDef_SDL_Integer(&((*yVar).Handle));
}

/*------------------EQUAL-------------------*/
#ifndef XNOPROTO
extern SDL_Boolean yEq_TRInvokeIndType(
  TRInvokeIndType yExpr1,
  TRInvokeIndType yExpr2 )
#else
extern SDL_Boolean yEq_TRInvokeIndType( yExpr1, yExpr2 )
  TRInvokeIndType yExpr1, yExpr2;
#endif
{
  if ( yNEqF_AddressType(yExpr1.SourceAddress, yExpr2.SourceAddress) )
  return SDL_False;
  if ( yNEqF_AddressType(yExpr1.DestinationAddress,
  yExpr2.DestinationAddress) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.AckType, yExpr2.AckType) ) return SDL_False;
  if ( yNEqF_pdubuf_ptr(yExpr1.UserData, yExpr2.UserData) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.ClassType, yExpr2.ClassType) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.Handle, yExpr2.Handle) ) return SDL_False;
  return SDL_True;
}

/*-------------------MAKE-------------------*/
#ifndef XNOPROTO
extern TRInvokeIndType yMake_TRInvokeIndType(
  AddressType ySourceAddress,
  AddressType yDestinationAddress,
  SDL_Integer yAckType,
  pdubuf_ptr yUserData,
  SDL_Integer yClassType,
  SDL_Integer yHandle )
#else
extern TRInvokeIndType  yMake_TRInvokeIndType( ySourceAddress,
  yDestinationAddress, yAckType, yUserData, yClassType, yHandle )
  AddressType ySourceAddress;
  AddressType yDestinationAddress;
  SDL_Integer yAckType;
  pdubuf_ptr yUserData;
  SDL_Integer yClassType;
  SDL_Integer yHandle;
#endif
{
  TRInvokeIndType  yVar;
  memset((void *)(&yVar), 0, sizeof(TRInvokeIndType));
  yAssF_AddressType(yVar.SourceAddress, ySourceAddress, XASSMAKE);
  yAssF_AddressType(yVar.DestinationAddress, yDestinationAddress, XASSMAKE);
  yAssF_SDL_Integer(yVar.AckType, yAckType, XASSMAKE);
  yAssF_pdubuf_ptr(yVar.UserData, yUserData, XASSMAKE);
  yAssF_SDL_Integer(yVar.ClassType, yClassType, XASSMAKE);
  yAssF_SDL_Integer(yVar.Handle, yHandle, XASSMAKE);
  return yVar;
}

/*****
* NEWTYPE TRResultIndType  (BODY section)
* <<PACKAGE WSPConnectionMode_WTP>>
* #SDTREF(SDL,D:\WIP\Maintenance\4.x\System\SystemConfigurations\base_push_wta_wtls_co_korea\sdl\packages\wspconnectionmode_wtp.sun(1),164(25,50),24)
******/

/*------------------DEFAULT-----------------*/
#ifndef XNOPROTO
extern void yDef_TRResultIndType( TRResultIndType *yVar )
#else
extern void yDef_TRResultIndType( yVar )
  TRResultIndType *yVar;
#endif
{
  yDef_pdubuf_ptr(&((*yVar).UserData));
  xDef_SDL_Integer(&((*yVar).Handle));
  xDef_SDL_Boolean(&((*yVar).MoreData));
  xDef_SDL_Natural(&((*yVar).TotalSize));
}

/*------------------EQUAL-------------------*/
#ifndef XNOPROTO
extern SDL_Boolean yEq_TRResultIndType(
  TRResultIndType yExpr1,
  TRResultIndType yExpr2 )
#else
extern SDL_Boolean yEq_TRResultIndType( yExpr1, yExpr2 )
  TRResultIndType yExpr1, yExpr2;
#endif
{
  if ( yNEqF_pdubuf_ptr(yExpr1.UserData, yExpr2.UserData) ) return SDL_False;
  if ( yNEqF_SDL_Integer(yExpr1.Handle, yExpr2.Handle) ) return SDL_False;
  if ( yNEqF_SDL_Boolean(yExpr1.MoreData, yExpr2.MoreData) ) return SDL_False;
  if ( yNEqF_SDL_Natural(yExpr1.TotalSize, yExpr2.TotalSize) ) return SDL_False;
  return SDL_True;
}

/*-------------------MAKE-------------------*/
#ifndef XNOPROTO
extern TRResultIndType yMake_TRResultIndType(
  pdubuf_ptr yUserData,
  SDL_Integer yHandle,
  SDL_Boolean yMoreData,
  SDL_Natural yTotalSize )
#else
extern TRResultIndType  yMake_TRResultIndType( yUserData, yHandle, yMoreData,
  yTotalSize )
  pdubuf_ptr yUserData;
  SDL_Integer yHandle;
  SDL_Boolean yMoreData;
  SDL_Natural yTotalSize;
#endif
{
  TRResultIndType  yVar;
  memset((void *)(&yVar), 0, sizeof(TRResultIndType));
  yAssF_pdubuf_ptr(yVar.UserData, yUserData, XASSMAKE);
  yAssF_SDL_Integer(yVar.Handle, yHandle, XASSMAKE);
  yAssF_SDL_Boolean(yVar.MoreData, yMoreData, XASSMAKE);
  yAssF_SDL_Natural(yVar.TotalSize, yTotalSize, XASSMAKE);
  return yVar;
}

extern void yInit_WSPConnectionMode_WTP XPP((void))
{
  static int IsCalled = 0;
  if (IsCalled) return;
  IsCalled = 1;
  yInit_Global_Declarations();
}
