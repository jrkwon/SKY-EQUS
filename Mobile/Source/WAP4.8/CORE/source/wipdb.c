/*
 * Copyright (C) Ericsson Mobile Communications AB, 2000.
 * Licensed to AU-System AB.
 * All rights reserved.
 *
 * This software is covered by the license agreement between
 * the end user and AU-System AB, and may be used and copied
 * only in accordance with the terms of the said agreement.
 *
 * Neither Ericsson Mobile Communications AB nor AU-System AB
 * assumes any responsibility or liability for any errors or inaccuracies in
 * this software, or any consequential, incidental or indirect damage arising
 * out of the use of the Generic WAP Client software.
 */
/*
 * wipdb.c
 *
 * Simple database system.
 *
 *
 * Created by Niclas Kellgren 000606.
 *
 * Revision history:
 *   000703  NKE  first version
 *   000728  NKE  data channel handling added
 *   000804  NKE  data channel handling updated 
 *   000807  NKE  new data channel functions added
 *   000809  NKE  bugfixes
 *   000817  NKE  the object template is changed into a general object
 *   000822  NKE  constants for default fields changed
 *   000906  NKE  pattern matching added for getDataChannel
 *   000914  NKE  data channel handling moved to dbFunct.c
 *   001013  NKE  added persistent memory handling
 *   001101  NKE  write through rewritten
 *   001114  NKE  bugfixes and minor updates
 *   001212  NKE  corrected db_saveElement_wt
 *   010219  NKE  added db prefix to functions
 *   010301  NKE  major restructuring: changed underlying datastructure,
                  removed recursion and added db_getElementData
 *   010302  NKE  added persistent backup handling
 *   010309  NKE  added db_createStr and db_createMem
 *   010314  NKE  corrected db_setItem
 *   010320  NKE  corrected db_getElementData
 *   010321  NKE  minor corrections
 *   010514  NKE  added db_moveRecord and some enhancements to handle backup/write-through
 *                conflicts generated by the new function.
 *   010613  NKE  db_createStr and db_createMem can now create str/mem of zero length
 */

#include "wipdb.h"



/*************
 * Constants *
 *************/

/* 16-bit flag field

  pos len use
  ------------------
  0-2  3  type
   3   1  key present
   4   1  backup
   5   1  write-through
  6-7  2  data use, compactation of 'type'; what the 'data' field is used for
          rec,set = has child; int, ptr = internal data; str,mem = external data
   8   1  last element in list
   9   1  temporary flag. Signals last element in list and is a copy of bit 8,
          during the backup process. Is also used as a signal to db_copyRecord.

  Only one of the backup and write-through flags can be set at the same time. 

  If more flags are added, be careful to update all places where they are used.
  Search for BOOKMARK:FLAGS.
*/

enum DB_ElementType {
  DB_flag_rec          = 0x0000,
  DB_flag_set          = 0x0001, 
  DB_flag_int          = 0x0002,
  DB_flag_str          = 0x0003,
  DB_flag_mem          = 0x0004,
  DB_flag_ptr          = 0x0005,

  DB_flag_key          = 0x0008,

  DB_flag_backup       = 0x0010,
  DB_flag_writeThrough = 0x0020,

  DB_flag_dataChild    = 0x0000,
  DB_flag_dataInternal = 0x0040,
  DB_flag_dataExternal = 0x0080,

  DB_flag_lastElement  = 0x0100,
  DB_flag_temporary    = 0x0200,

  /* These flags are only used during backup. They reuse backup
   * and writeThrough bits. */
  DB_flag_lastElement2 = DB_flag_temporary,
  DB_flag_hasChild     = DB_flag_backup,
  DB_flag_endOfBuffer  = DB_flag_writeThrough,
  DB_flag_rootLevel    = DB_flag_lastElement,
  /* The temporary flag is in db_copyRecord to treat str and
   * mem pointers as ptr, i.e. only copy the pointer and not
   * the data pointed out. */
  DB_flag_move         = DB_flag_temporary
};


enum MaskType {
  DB_mask_type         = 0x0007,

  DB_mask_key          = DB_flag_key,

  DB_mask_backup       = DB_flag_backup,
  DB_mask_writeThrough = DB_flag_writeThrough,
  DB_mask_persistent   = DB_flag_backup | DB_flag_writeThrough,

  DB_mask_dataUse      = 0x00C0,

  DB_mask_lastElement  = DB_flag_lastElement,

  DB_mask_lastElement2 = DB_flag_lastElement2,
  DB_mask_hasChild     = DB_flag_hasChild,
  DB_mask_endOfBuffer  = DB_flag_endOfBuffer,
  DB_mask_rootLevel    = DB_flag_rootLevel,
  DB_mask_move         = DB_flag_move
};


enum {
  DB_max  = DB_root-1,                   /* Maximum number of created records.                */

  DB_refHashSize = 32,                   /* Must be 2**n, unsigned int n, n > 0.              */
  DB_refHashMask = 32 - 1,               /* Must be DB_refHashSize - 1.                       */

  DB_keyLen = 6                          /* Element key length. Must be at least 6 long.      */
};


#define BUFSIZE 64                       /* Size of persistent storage buffer. Must fit
                                          * everything but the data and be multiple of 8.     */

#define GOING_UP    0
#define GOING_DOWN  1
#define GOING_RIGHT 2


/*********
 * Types *
 *********/

typedef union {
  UINT32                i;
  void*                 p;
  BYTE*                 s;
  struct RecordStruct*  r;
  struct FieldStruct*   f;
  struct ElementStruct* e;

} DataUnion;


typedef struct ElementStruct* ElementPtr;
typedef struct ElementStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;

} Element;

typedef struct ElementBlockStruct* ElementBlockPtr;
typedef struct ElementBlockStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;
  UINT32     blockId;

} ElementBlock;



typedef struct FieldStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;
  BYTE       key[DB_keyLen];

} Field, *FieldPtr;

typedef struct FieldBlockStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;
  BYTE       key[DB_keyLen];
  UINT32     blockId;

} FieldBlock, *FieldBlockPtr;



typedef struct RecordStruct* RecordPtr;
typedef struct RecordStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;
  BYTE       key[DB_keyLen];
  UINT16     ref;
  RecordPtr  nextRec; 

} Record;

typedef struct RecordBlockStruct* RecordBlockPtr;
typedef struct RecordBlockStruct {
  ElementPtr next;
  DataUnion  data;
  UINT16     flags;
  BYTE       key[DB_keyLen];
  UINT16     ref;
  RecordPtr  nextRec; 
  UINT32     blockId;

} RecordBlock;


/*************
 * Variables *
 *************/

static RecordPtr* refHashTable;            /* Hash table of liked list. RecordPtr.nextRec.     */
static DB_ref     recordNbr = 0;           /* Record counter. Null reference is number 0.      */

static RecordPtr  db_root;                 /* Pointer to database root element.                */

static RecordPtr  currentRecord = NULL;    /* Used by db_findField/db_deleteElement.           */
static DB_ref     currentRef    = DB_null; /* Matches currentRecord. Used for caching.         */

static ElementPtr currentElement;          /* Carries information between several functions:
                                            * from db_findField and db_deleteItem_ptr to 
                                            * db_findRecord, db_deleteElement.                 */

static ElementPtr prevElement;             /* Carries information between several functions:
                                            * from db_findField and db_deleteItem_ptr to 
                                            * db_deleteElement                                 */

static StorageObject store;                /* Main object used by storage.c                    */

static BOOL       db_serviceMode;          /* Is set to TRUE at startup or shutdown. Protects
                                            * presistent memory during rebuild or close-down.  */

static BOOL       db_saveDataMode;         /* When set to TRUE, db_deleteItem, db_deleteItem_ptr
                                            * and db_clearRecord will not remove data poined out
                                            * by a mem or str type. They are treated as ptr.   */

static UINT32*    idArr;                   /* Pointer to list of ids of elments on persistent
                                            * memory. Only used during startup.                */

/************************
 * Forward declarations *
 ************************/

UINT8 db_deleteItem_ptr (RecordPtr rec, ElementPtr element);
static UINT32 db_getBlockId(ElementPtr element);
static void db_deleteElement_wt(RecordPtr parent, ElementPtr current, ElementPtr prev);
static BOOL db_saveElement_wt(RecordPtr parent, ElementPtr element, ElementPtr prev);
static BOOL db_loadDB_wt(void);
static void db_saveDB_bu(void);
static BOOL db_loadDB_bu (void);

/*************
 * Functions *
 *************/

/* ============================================ */
/* ==========  Main functionality  ============ */
/* ============================================ */


/*
  This module contains the main functionality of the database.
  It has five parts:

  * help functions
  * get
  * set
  * structural operations
  * administration


  FUNCTIONS

  A list of the most important functions:

  * help functions
  db_findRecord
  db_findField
  db_findPrev_wt
  db_addBelow
  db_addAfter
  db_deleteContent
  db_deleteElement

  * get
  db_getElementData
  db_getRef
  db_getType

  * set
  db_createNewElement
  db_setItem
  db_setInt
  db_setStr
  db_setMem
  db_setPtr

  * structural operations
  db_createNewRecord
  db_createRecord
  db_copyRecord
  db_deleteItem
  db_deleteItem_ptr
  db_clearRecord
  db_moveToFront

  * administration
  db_dbInit
  db_dbTerminate
  
  
*/

/* ======== help functions ======== */


/*
 * Search hash structure for record. Sets currentRecord and 
 * currentRef. Must be called prior to db_findField.
 */
RecordPtr 
db_findRecord (DB_ref record)
{
  RecordPtr rec;
  
  if (record == currentRef) /* Speed up the most common case by caching */
    return currentRecord;
  rec = refHashTable[record & DB_refHashMask];
  while (TRUE) {
    if (rec == NULL) {
      currentRef = DB_null;
      break;
    } else if (rec->ref == record) {
      currentRef = record;
      break;
    } else
      rec = rec->nextRec;
  }
  currentRecord = rec;
  return currentRecord;
}



/*
 * Find field named 'key' if present, else return NULL. Sets 
 * currentElement and prevElement. currentRecord defines the record
 * to search and db_findRecord must be called first to set it.
 *
 * Can only be used on records, NOT on sets. Depends on currentRecord.
 */
FieldPtr 
db_findField (const BYTE* key) 
{
  const BYTE* t;
  BYTE*       s;

  prevElement = NULL;
  if (key == NULL)
    return NULL;
  if ((currentRecord->flags & DB_mask_type) != DB_flag_rec)
    return NULL;

  currentElement = currentRecord->data.e;
  while (currentElement != (ElementPtr) currentRecord) {
    for (s = ((FieldPtr) currentElement)->key, t = key; *s == *t; s++, t++)
      if (*s == '\0')
        return (FieldPtr) currentElement;
    prevElement = currentElement;
    currentElement = currentElement->next;
  }
  currentElement = NULL;
  return NULL;
}



/*
 * Find the closest predecessor to currentElement with
 * write-through flag set at root level.
 */
static ElementPtr 
db_findPrev_wt (ElementPtr element) 
{
  ElementPtr prev;
  ElementPtr current;

  prev = NULL;
  current = db_root->data.e;
  while (current != (ElementPtr) db_root) {
    if (current == element)
      return prev;
    if (current->flags & DB_mask_lastElement)
      prev = current;
    current = current->next;
  }
  return NULL;
}



/*
 * Insert a new element 'newElement' below 'rec'.
 */
static void 
db_addBelow (RecordPtr rec, ElementPtr newElement)
{
  if (rec->data.e == (ElementPtr) rec)
    newElement->flags |=   DB_flag_lastElement;
  else
    newElement->flags &= ~ DB_flag_lastElement;
  
  newElement->next = rec->data.e;
  rec->data.e = newElement;
}



/*
 * Insert a new element 'newElement' after 'element'.
 */
static void 
db_addAfter (ElementPtr element, ElementPtr newElement)
{
  if (element->flags & DB_mask_lastElement) {
    element->flags &= ~ DB_flag_lastElement;
    newElement->flags |= DB_flag_lastElement;
  } else
    newElement->flags &= ~ DB_flag_lastElement;

  newElement->next = element->next;
  element->next = newElement;
}



/*
 * Remove 'current' element from reference hash list. Used by
 * db_deleteContent and db_deleteElement;
 */
static void 
db_removeElementRef (ElementPtr current)
{
  RecordPtr  rec;
  RecordPtr* prevPtr;

  prevPtr = refHashTable + (((RecordPtr) current)->ref & DB_refHashMask);
  rec = *prevPtr;
  while (rec->ref != ((RecordPtr) current)->ref) {
    prevPtr = &rec->nextRec; 
    rec = rec->nextRec;
  }
  *prevPtr = rec->nextRec;
}



/*
 * Delete entire subtree, excluding 'rec' root element. Does
 * not update rec->data.e. Preserves ref hash structure.
 *
 * Elements are removed bottom up non-recursively. If 'saveData'
 * is TRUE, then external data is not deleted.
 *
 * This is a utility function, intended to be used by other
 * functions. Use db_clearRecord if you want to delete all
 * fields of a record and preserv write-through consistency.
 */
static void 
db_deleteContent (RecordPtr rec, BOOL saveData)
{
  ElementPtr current;
  ElementPtr prev;
  UINT32     id;

  current = rec->data.e;
  while (current != (ElementPtr) rec) {
    switch (current->flags & DB_mask_dataUse) {
    case DB_flag_dataChild:
      if (current->data.e != current) {
        /* This element has a child and cannot be removed (yet) */
        current = current->data.e;
        continue;
      } else
        db_removeElementRef(current);
      break;

    case DB_flag_dataExternal:
      if (! saveData)
        OSConnectorFree(current->data.s);
    }

    if (current->flags & DB_mask_writeThrough && ! db_serviceMode) {
      id = db_getBlockId(current);
      Storage_DeleteBlock(&store, id); 
    }

    prev = current;
    current = current->next;
    if (prev->flags & DB_mask_lastElement)  /* Finished one level */
      current->data.e = current; /* Mark this record as empty, i.e. deletable */
    OSConnectorFree(prev);
  }
}



/*
 * Delete currentElement. If it is a record or set, use 
 * db_deleteContent to remove the subtree. Preserves ref hash 
 * structure. If 'saveData' is TRUE, then external data is
 * not deleted.
 *
 * Depends on currentElement, currentRecord, prevElement. If
 * you change currentRecord, don't forget to update currentRef.
 */
static void 
db_deleteElement (BOOL saveData)
{
  if (currentElement->flags & DB_mask_writeThrough && ! db_serviceMode)
    db_deleteElement_wt(currentRecord, currentElement, prevElement);

  if (prevElement == NULL)
    currentRecord->data.e = currentElement->next;
  else {
    prevElement->next = currentElement->next;
    if (prevElement->next == (ElementPtr) currentRecord)
      prevElement->flags |= DB_flag_lastElement;
  }

  switch (currentElement->flags & DB_mask_dataUse) {
  case DB_flag_dataChild:
    db_removeElementRef(currentElement);
    
    if (currentElement->data.e != currentElement)
      db_deleteContent((RecordPtr) currentElement, saveData);
    break;

  case DB_flag_dataExternal:
    if (! saveData)
      OSConnectorFree(currentElement->data.s);
  }
  OSConnectorFree(currentElement);
}



#define DB_DUPLICATE_STR(s) {UINT8 error; db_duplicateStrMem(s, DB_flag_str, &error;}
#define DB_DUPLICATE_MEM(s) {UINT8 error; db_duplicateStrMem(s, DB_flag_mem, &error;}
/*
 * Copy a string or memory block.
 */
static BYTE* 
db_duplicateStrMem (BYTE* s, UINT16 type, UINT8 *errorCode)
{
  BYTE*  temp;
  size_t len;

  if (type == DB_flag_str) /* str */
    len = strlen((char*) s) + 1;
  else /* mem */
    len = *(UINT16*) s;

  temp = (BYTE*) OSConnectorAlloc(len);
  #ifndef HAS_SETJMP
  /* NOTE: if this paragraph is removed, also remove the 'errorCode' parameter and change macros! */
  if (temp == NULL) {
    *errorCode = DB_err_outOfMemory;
    return NULL;
  }
  #endif
  memcpy(temp, s, len);

  *errorCode = DB_err_success;
  return temp;
}



/*
 * Create a null-terminated string by allocating new memory and
 * copying 'length' characters from 'p'.
 */
BYTE* db_createStr (const char* p, UINT16 length) {
  BYTE* ptr = NULL;

  ptr = (BYTE*) OSConnectorAlloc (length + 1);
  if (ptr) {
    if (length > 0 && p != NULL)
      memcpy(ptr, p, length);
    ptr[length] = '\0';
  }

  return ptr;
}



/*
 * Create a memory block by allocating new memory and
 * copying 'length' characters from 'p'.
 */
BYTE* db_createMem (const char* p, UINT16 length) {
  BYTE* ptr = NULL;

  ptr = (BYTE*) OSConnectorAlloc (length + sizeof(UINT16));
  if (ptr) {
    if (length > 0 && p != NULL)
      memcpy (ptr + sizeof (UINT16), p, length);
    *(UINT16*) ptr = length + sizeof (UINT16);
  }

  return ptr;
}



/*
 * Update nextId field in persistent memory. Do not use ';'
 * after macro;
 *
 * ElementPtr element
 * UINT32     nextId
 */
#define DB_SET_NEXT_ID(element, nextId) \
{UINT32 temp = (nextId); Storage_Put(&store, db_getBlockId(element), 0, 4, &temp);}



/*
 * Update childId field in persistent memory. Do not use ';'
 * after macro;
 *
 * UINT32 id
 * UINT32 nextId
 */
#define DB_SET_CHILD_ID(id, nextId) \
{UINT32 temp = (nextId); Storage_Put(&store, (id), 4, 4, &temp);}



/*
 * Search through idArr and sets the MSB of the element equal
 * to 'id'. Only used at startup by the write-through functions.
 */
static void 
db_markId (UINT32 id)
{
  UINT32* p;

  for (p=idArr; *p != id; p++)
    ;
  *p |= 0x80000000;
}



/* ======== get ======== */



/*
 * Return data from element. The element pointed out by 'record'
 * and 'key' must be of the of the same type as 'type' indicates,
 * with one exception:  it is legal to get a pointer from a 
 * string or memory block.
 *
 * If 'del' is true, the element is deleted and so is its data
 * with a few exceptions. Deleting a pointer element does not delete
 * its data. Getting a pointer from a string or memory block element 
 * and deleting it at the same time does not delete its data.
 *
 * 'type' takes the values of DB_int, DB_str, DB_mem or DB_ptr.
 */
DB_elementData 
db_getElementData (DB_ref record, const BYTE* key, BOOL del, UINT16 type, UINT8* errorCode)
{
  FieldPtr       field;
  DB_elementData temp;

  temp.i = 0;

  if (db_findRecord(record) == NULL) {
    *errorCode = DB_err_record;
    return temp;
  }
  field = db_findField(key);
  if (field == NULL) {
    *errorCode = DB_err_field;
    return temp;
  }
  
  {
  UINT16 elementType = field->flags & DB_mask_type;
  if (elementType != type && 
    !(type == DB_flag_ptr && (elementType == DB_flag_str || elementType == DB_flag_mem))) {
    *errorCode = DB_err_wrongType;
    return temp;
  }
  }
  *errorCode = DB_err_success;

  if (del) {
    temp = *(DB_elementData*) &field->data;
    db_deleteElement(TRUE);
  } else {
    if (type == DB_flag_ptr)                               /* ptr or str/mem + db_getPtr() */
      temp.p = field->data.p;
    else if ((field->flags & DB_mask_type) == DB_flag_int) /* int */
      temp.i = field->data.i;
    else                                                   /* str, mem */
      temp.s = db_duplicateStrMem(field->data.s,
                               (UINT16) (field->flags & DB_mask_type), errorCode);
      /* errorCode may signal and error, but may be passed on since
       * there is no code between here and the end of the function. */
  }
  return temp;
}



/*
 * Return reference to record element.
 */
DB_ref 
db_getRef (DB_ref record, const BYTE* key, UINT8* errorCode)
{
  FieldPtr field;

  if (db_findRecord(record) == NULL) {
    *errorCode = DB_err_record;
    return DB_null;
  }
  field = db_findField(key);
  if (field == NULL) {
    *errorCode = DB_err_field;
    return DB_null;
  }
  if ((field->flags & DB_mask_dataUse) != DB_flag_dataChild) {
    *errorCode = DB_err_wrongType;
    return DB_null;
  } else {
    *errorCode = DB_err_success;
    currentRecord = (RecordPtr)field;      /* Guess the next search uses the\*/
    currentRef = ((RecordPtr)field)->ref;  /* returned ref. Cache result. */
    return currentRef;
  }
}



/*
 * Return type of element.
 */
UINT8 
db_getType (DB_ref record, const BYTE* key, UINT8* errorCode)
{
  FieldPtr field;

  if (db_findRecord(record) == NULL) {
    *errorCode = DB_err_record;
    return 0;
  }
  field = db_findField(key);
  if (field == NULL) {
    *errorCode = DB_err_field;
    return 0;
  }
  *errorCode = DB_err_success;
  return field->flags & DB_mask_type;
}





/* ======== set ======== */

/*
 * Create a new element. 'rec' is used for deciding persistent
 * state and and seting key flag. The new element is added
 * after 'prev' if 'prev' != NULL, else as first element below
 * 'rec'. If 'element' != NULL, it is updated with 'data' and
 * no new element is created. 
 */
/* BOOKMARK:FLAGS */
ElementPtr 
db_createNewElement (RecordPtr rec, const BYTE* key, UINT16 flags, DataUnion data,
                               ElementPtr prev, ElementPtr element, UINT8 *errorCode)
{
  BYTE*      s;
  int        i;

  if (rec != db_root)
    /* Inherit the parent's persistent status */
    flags = (flags & ~ DB_mask_persistent) | (rec->flags & DB_mask_persistent);

  if (flags & DB_mask_persistent && (flags & DB_mask_type) == DB_flag_ptr) {
      *errorCode = DB_err_persistentTypeError;
      return NULL;
  }

  /* Create element */
  if ((rec->flags & DB_mask_type) == DB_flag_set) { 
    /* --------------------------------------------------------  DB_flag_set */
    /* ===================================================  Create a new element */
    if (flags & DB_mask_writeThrough)
      element = (ElementPtr) OSConnectorAlloc(sizeof(ElementBlock));
    else
      element = (ElementPtr) OSConnectorAlloc(sizeof(Element));
    #ifndef HAS_SETJMP
    if (element == NULL) {
      *errorCode = DB_err_outOfMemory;
      return NULL;
    }
    #endif
    element->flags = 0; /* clear DB_flag_key */

  } else {  
    /* --------------------------------------------------------  DB_flag_rec */
    if (key == NULL) {
      *errorCode = DB_err_nullValue;
      return NULL;
    }
    
    if (element != NULL) { /* ============================  Update existing element */
      if ((element->flags & DB_mask_type) != (flags & DB_mask_type)) {
        *errorCode = DB_err_wrongType;
        return NULL;
      } else {
        if ((flags & DB_mask_dataUse) == DB_flag_dataExternal)
          OSConnectorFree(element->data.s);
        element->data = data;
        if (flags & DB_mask_writeThrough)
          if (! db_saveElement_wt(rec, element, prev))
            /* No persistent save, set warning. Return value still valid. */
            *errorCode = DB_err_noPersistentSave;
        return element;
      }
    
    } else { /* ==========================================  Create a new element */
      if (flags & DB_mask_writeThrough)
        element = (ElementPtr) OSConnectorAlloc(sizeof(FieldBlock));
      else
        element = (ElementPtr) OSConnectorAlloc(sizeof(Field));
      #ifndef HAS_SETJMP
      if (element == NULL) {
        *errorCode = DB_err_outOfMemory;
        return NULL;
      }
      #endif
      
      /* Copy key */
      for (s=((FieldPtr)element)->key, i=1; *s = *key; s++, key++, i++)
        if (i == DB_keyLen) { /* In case of too long input keys. */
          OSConnectorFree(element);
          *errorCode = DB_err_tooLongKey;
          return NULL;
        }
      element->flags = DB_flag_key;
    }
  }

  /* Init data */
  element->flags |= flags;
  element->data   = data;

  /* Add element */
  if (prev == NULL)
    db_addBelow(rec, (ElementPtr) element);
  else
    db_addAfter(prev, (ElementPtr) element);

  /* Save element, if write-through */
  *errorCode = DB_err_success;
  if (flags & DB_mask_writeThrough && ! db_serviceMode) {
    if (element->flags & DB_mask_key)
      ((FieldBlockPtr) element)->blockId = 0;
    else
      ((ElementBlockPtr) element)->blockId = 0;
    if (! db_saveElement_wt(rec, element, prev))
      /* No persistent save, set warning. Return value still valid. */
      *errorCode = DB_err_noPersistentSave;
  }

  return element;
}



/*
 * Create and insert an Element or Field. If an element named
 * 'key' already exists, 'flags' must signal the same type of
 * the element. Old strings or memory blocks are freed.
 *
 * If NULL is returned, an error has occurred and its number
 * is returned in 'errorCode'.
 */
static ElementPtr 
db_setItem (DB_ref record, const BYTE* key, UINT16 flags, DataUnion data,
                      UINT8 *errorCode)
{
  ElementPtr element;
  RecordPtr  rec;

  *errorCode = DB_err_success;

  rec = db_findRecord(record);
  if (rec == NULL) { 
    *errorCode = DB_err_record;
    return NULL;
  }
  
  db_findField(key);
  element = db_createNewElement(rec, key, flags, data, NULL, currentElement, errorCode);

  return element;
}



/*
 * Update or insert an int field.
 */
UINT8 
db_setInt (DB_ref record, const BYTE* key, INT32 value)
{
  DataUnion  data;
  UINT8      error;

  data.i = value; /* BOOKMARK:FLAGS */
  db_setItem(record, key, DB_flag_int | DB_flag_dataInternal, data, &error);
  return error;
}



/*
 * Update or insert a string field. 'value' is taken over by
 * the database and is deallocated when this element is deleted.
 */
UINT8 
db_setStr (DB_ref record, const BYTE* key, BYTE* value)
{
  DataUnion  data;
  UINT8      error;

  if (value == NULL)
    return DB_err_nullValue;
  data.s = value; /* BOOKMARK:FLAGS */
  db_setItem(record, key, DB_flag_str | DB_flag_dataExternal, data, &error);
  return error;
}



/*
 * Update or insert a memory block field. 'value' is taken over by
 * the database and is deallocated when this element is deleted.
 */
UINT8 
db_setMem (DB_ref record, const BYTE* key, BYTE* value)
{
  DataUnion  data;
  UINT8      error;

  if (value == NULL)
    return DB_err_nullValue;
  data.s = value; /* BOOKMARK:FLAGS */
  db_setItem(record, key, DB_flag_mem | DB_flag_dataExternal, data, &error);
  return error;
}



/*
 * Update or insert a pointer field.
 */
UINT8 
db_setPtr (DB_ref record, const BYTE* key, void* value)
{
  DataUnion  data;
  UINT8      error;

  data.p = value; /* BOOKMARK:FLAGS */
  db_setItem(record, key, DB_flag_ptr | DB_flag_dataInternal, data, &error);
  return error;
}



/* ======== structural operations ======== */


/*
 * Create a new record.
 *
 * The only bits of 'flags' used are the persistent flags and
 * DB_flag_rec/DB_flag_set.
 */
static RecordPtr 
db_createNewRecord (RecordPtr rec, const BYTE* key, UINT16 flags, ElementPtr prev,
                    UINT8 *errorCode)
{
  RecordPtr  newRec;
  BYTE*      s;
  int        len;

  if (rec == db_root) {
    if (flags & DB_mask_writeThrough)
      /* Write-through and backup cannot be active at the same time */
      flags &= ~DB_flag_backup;
  } else
    /* Inherit the parent's persistent status */
    flags = flags & ~ DB_mask_persistent | rec->flags & DB_mask_persistent;

  /* Create record */
  if (flags & DB_mask_writeThrough)
    newRec = (RecordPtr) OSConnectorAlloc(sizeof(RecordBlock)); 
  else
    newRec = (RecordPtr) OSConnectorAlloc(sizeof(Record)); 
  #ifndef HAS_SETJMP
  if (newRec == NULL) {
    *errorCode = DB_err_outOfMemory;
    return NULL;
  }
  #endif
  
  /* Copy key */
  for (s=newRec->key, len=1; *s = *key; s++, key++, len++) 
    if (len == DB_keyLen) {
      OSConnectorFree(newRec);
      *errorCode = DB_err_tooLongKey;
      return NULL;
    }

  /* Init data */
  newRec->data.r = newRec;  
  newRec->flags = flags & DB_mask_persistent;
  if ((flags & DB_mask_type) == DB_flag_rec)  /* BOOKMARK:FLAGS */
    newRec->flags |= DB_flag_rec | DB_flag_key | DB_flag_dataChild; /* rec */
  else
    newRec->flags |= DB_flag_set | DB_flag_key | DB_flag_dataChild; /* set */
  newRec->ref     = ++recordNbr;
  
  /* Add element */
  newRec->nextRec = refHashTable[recordNbr & DB_refHashMask];
  refHashTable[recordNbr & DB_refHashMask] = newRec;

  if (prev == NULL)
    db_addBelow(rec, (ElementPtr) newRec);
  else
    db_addAfter(prev, (ElementPtr) newRec);

  /* Save element, if write-through */
  *errorCode = DB_err_success;
  if (flags & DB_mask_writeThrough && ! db_serviceMode) {
    ((RecordBlockPtr) newRec)->blockId = 0;
    if (! db_saveElement_wt(rec, (ElementPtr) newRec, prev))
      /* No persistent save, set warning. Anyway, the record was created. */
      *errorCode = DB_err_noPersistentSave;     
  }

  return newRec;
}



/*
 * Create a new record. If a field with the same name exists, an
 * error will be generated, except when the parent record is a
 * set. If 'flags' bit 0 is set, it signals this is a set, not a
 * record. This can be done by using paramater DB_set instead of
 * DB_rec for record.
 *
 * 'errorCode' returns the status of the function. DB_err_success
 * when the operation i successfully completed.
 *
 * If 'key' is NULL, the key of the new record will be an empty
 * string.
 */
DB_ref 
db_createRecord (DB_ref record, const BYTE* key, UINT16 flags, UINT8 *errorCode)
{
  RecordPtr newRec;
  RecordPtr rec;

  if (recordNbr == DB_max) { 
    *errorCode = DB_err_outOfRefs;
    return DB_null;
  }

  rec = db_findRecord(record);
  if (rec == NULL) { 
    *errorCode = DB_err_record;
    return DB_null;
  } 
  if ((rec->flags & DB_mask_type) == DB_flag_rec && db_findField(key)) {
    *errorCode = DB_err_exists;
    return DB_null;
  }

  if (key == NULL || (rec->flags & DB_mask_type) == DB_flag_set)
    key = (BYTE*) &"";

  newRec = db_createNewRecord(rec, key, flags, NULL, errorCode);
  if (*errorCode != DB_err_success)
    return DB_null;

  currentRecord = newRec; /* Assume this record will be used in \*/
  currentRef = recordNbr; /* the next operation. Cache record. */

  return recordNbr;
}



/*
 * Make an copy of a record and is fields. The element order is
 * preserved. Fields of type int, str and mem are copied. For
 * pointer fields, only the pointer is copied, not the content
 * pointed out.
 * 
 * Even if the original is write through or backup, the copy
 * may or may not be. Instead 'flags' can be set to DB_writeThrough
 * or DB_backup to indicate the new persistent state. This
 * parameter is only used when the destination 'to' is DB_root.
 * Otherwise the persistent state is inherited from the parent,
 * i.e. from the 'to' record. Use DB_noPersistentSave when no
 * persistent save is wanted.
 *
 * 'key' is the name of the copy. If 'key' is NULL, the original
 * name will be used. 
 *
 * If an error occurs, all work is undone and a correct
 * structrure is maintained.
 *
 * It is legal to insert the copy into the source tree.
 *
 * A reference to the new record is returned.
 */
DB_ref 
db_copyRecord (DB_ref from, DB_ref to, BYTE* key, UINT16 flags, UINT8 *errorCode)
{
  ElementPtr fromElement;
  ElementPtr topFromElement;
  ElementPtr toElement;
  ElementPtr topToElement;
  RecordPtr  toRec;
  RecordPtr  topToRec;
  ElementPtr newElement;
  DataUnion  data;
  UINT16     copyData;
  short      direction;

  fromElement = (ElementPtr) db_findRecord(from);
  toRec = db_findRecord(to); /* Search is continued further down (X) */
  if (fromElement == NULL || toRec == NULL) {
    *errorCode = DB_err_record;
    return DB_null;
  }

  topFromElement = fromElement;
  topToRec = toRec;
  direction = GOING_DOWN;

  if (key == NULL) 
    if (fromElement->flags & DB_mask_key)
      key = ((FieldPtr) fromElement)->key;
    else {
      *errorCode = DB_err_noKeyGiven;
      return DB_null;
    }

  if ((toRec->flags & DB_mask_type) == DB_flag_rec && db_findField(key)) { /* (X) */
    *errorCode = DB_err_exists;
    return DB_null;
  }

  copyData = ! (flags & DB_mask_move);

  /* Create first element */
  /* BOOKMARK:FLAGS */
  flags = flags & DB_mask_persistent | fromElement->flags & ~ DB_mask_persistent;
  newElement = (ElementPtr) db_createNewRecord(toRec, key, flags , NULL, errorCode);
  if (*errorCode != DB_err_success)
    return NULL;
  topToElement = newElement;
  toElement = newElement;
  
  for (;;) {
    /* Move to next element */
    if (direction != GOING_UP && (fromElement->flags & DB_mask_dataUse) == DB_flag_dataChild &&
        fromElement->data.e != fromElement)
    {
      direction = GOING_DOWN;
      toRec = (RecordPtr) toElement;
      fromElement = fromElement->data.e;
    } else {
      if (! (fromElement->flags & DB_mask_lastElement)) {
        direction = GOING_RIGHT;
      } else {
        toElement = toElement->next;
Undo_going_down:
        direction = GOING_UP;
        toRec = (RecordPtr) toRec->next;
      }
      fromElement = fromElement->next;
    }

    /* Prevent loops when dest in source. */
    if (fromElement == topToElement) {
      if (fromElement->flags & DB_mask_lastElement)
        /* Should never gone down. Now the the from-record contains
         * only a copy of the new tree. Originaly it was empty and
         * should be treated as if it still is. */
        goto Undo_going_down;
      else 
        /* Skip this element, which is the root of the copy.
         * 'direction' must be GOING_DOWN to attach next element
         * correctly. */
        fromElement = fromElement->next;
    }

    /* Check if all is done */
    if (fromElement == topFromElement)
      break;

    /* Create and add new element */
    if (direction != GOING_UP) {
      if ((fromElement->flags & DB_mask_dataUse) == DB_flag_dataChild)
        /* -----------------------------------------------------  rec, set */
        newElement = (ElementPtr) db_createNewRecord(toRec, ((FieldPtr) fromElement)->key,
                     fromElement->flags, direction == GOING_DOWN ? NULL : toElement, errorCode);
      else { /* ------------------------------------------------  int, str, mem, ptr */
        switch (fromElement->flags & DB_mask_dataUse) {
        case DB_flag_dataExternal:                      /* str, mem */
          if (copyData) {
            data.s = db_duplicateStrMem(fromElement->data.s,
                                         (UINT16) (fromElement->flags & DB_mask_type), errorCode);
            break;
          }
          /* fall through if DB_flag_move is set */
        case DB_flag_dataInternal:                      /* int, ptr */
          data = fromElement->data;
          break;
        }
        
        newElement = db_createNewElement(toRec, ((FieldPtr) fromElement)->key,
                           fromElement->flags, data, direction == GOING_DOWN ? NULL : toElement,
                           NULL, errorCode);
      }
      if (*errorCode != DB_err_success) {
        db_deleteItem_ptr(topToRec, topToElement);
        return NULL;
      }

      toElement = newElement;
    }
  }

  return ((RecordPtr) toElement)->ref;
}


  
/*
 * Move a record to a new destination. The element order is
 * preserved.
 *
 * Even if the original is write through or backup, the copy
 * may or may not be. Instead 'flags' can be set to DB_writeThrough
 * or DB_backup to indicate the new persistent state. This
 * parameter is only used when the destination 'to' is DB_root.
 * Otherwise the persistent state is inherited from the parent,
 * i.e. from the 'to' record. Use DB_noPersistentSave when no
 * persistent save is wanted.
 *
 * If an error occurs, all work is undone and a correct
 * structrure is maintained.
 *
 * A record moved into itself, it is deleted and the reference
 * returned is not valid. 
 *
 * A moved record gets a new reference and it is returned.
 */
DB_ref 
db_moveRecord (DB_ref from, DB_ref fromParent, DB_ref to, UINT16 flags, UINT8 *errorCode)
{
  BYTE      key[DB_keyLen];
  RecordPtr fromRec;
  RecordPtr fromParentRec;
  DB_ref    ref;

  fromRec = db_findRecord (from);
  fromParentRec = db_findRecord (fromParent);
  if (fromRec == NULL || fromParentRec == NULL)
    return DB_null;

  memcpy (key, fromRec->key, DB_keyLen);
  *fromRec->key = '\0';
  
  ref = db_copyRecord (from, to, key, (UINT16) (flags | DB_flag_move), errorCode);
  if (*errorCode != DB_err_success) {
    *fromRec->key = *key;
    return DB_null;
  }

  db_saveDataMode = TRUE;
  db_deleteItem_ptr (fromParentRec, (ElementPtr) fromRec);
  db_saveDataMode = FALSE;
  
  return ref;
}



/*
 * Remove the specified item. If it is a string or memory block,
 * associated data is freed. For records and sets, the entire
 * subtree is deleted.
 */
UINT8 
db_deleteItem (DB_ref record, const BYTE* key)
{
  if (! db_findRecord(record)) 
    return DB_err_record;

  if (! db_findField(key)) 
    return DB_err_field;

  db_deleteElement(db_saveDataMode);
  return DB_err_success;
}



/*
 * Same functionality as deleteItem. 'element' is a pointer to the
 * element to be deleted and 'rec' its parent.
 */
UINT8 
db_deleteItem_ptr (RecordPtr rec, ElementPtr element)
{
  if (rec == NULL || element == NULL) 
    return DB_err_nullValue;

  prevElement = NULL;
  currentElement = rec->data.e;
  while (currentElement != (ElementPtr) rec) {
    if (currentElement == element) {
      currentRecord = rec;
      currentRef = DB_null;
      db_deleteElement(db_saveDataMode);
      return DB_err_success;
    }
    prevElement = currentElement;
    currentElement = currentElement->next;
  }
  return DB_err_field;
}



/*
 * Remove all fields connected to 'record'. The entire subtree
 * is deleted. Works on both records and sets.
 */
UINT8
db_clearRecord (DB_ref record)
{
  if (! db_findRecord(record)) 
    return DB_err_record;

  if (currentRecord->flags & DB_mask_writeThrough)
    DB_SET_CHILD_ID(((RecordBlockPtr) currentRecord)->blockId, 0)

  db_deleteContent(currentRecord, db_saveDataMode);
  
  return DB_err_success;
}



/*
 * Move 'element' to the beginning of the list it is in.
 *
 * If the system crashes during this function, the
 * 'element' item may be lost, even when using persitent
 * memory. 
 */
void
db_moveToFront (RecordPtr parent, ElementPtr element)
{
  ElementPtr currentElem;
  ElementPtr prevElem;
  UINT32     prevId;

  /* Find previous element in list */
  currentElem = parent->data.e;
  prevElem = NULL;
  while (currentElem != element) {
    if (currentElem == (ElementPtr)parent)
      return;
    prevElem = currentElem;
    currentElem = currentElem->next;
  }
  if (prevElem == NULL)
    return;
  
  /* Move element to the beginning of the list */
  if (element->flags & DB_mask_writeThrough) {
    prevId = db_getBlockId(prevElem);
    if (element->next == (ElementPtr) parent)
      DB_SET_CHILD_ID(db_getBlockId((ElementPtr) parent), prevId)
    else
      DB_SET_NEXT_ID(element->next, prevId)
    DB_SET_NEXT_ID(element, 0)
    DB_SET_NEXT_ID(parent->data.e, db_getBlockId(element))
  } 
  
  if (currentElem->flags & DB_mask_lastElement) {
    currentElem->flags &= ~ DB_flag_lastElement;
    prevElem->flags |= DB_flag_lastElement;
  }
  prevElem->next = currentElem->next;
  currentElem->next = parent->data.e;
  parent->data.e = currentElem;
}



/* ======== administration ======== */

/*
 * Initiate the database and its structures.
 *
 * On some systems (Ericsson), when out of memory, the system
 * does not restart until the control has been returned to the
 * event loop. In this case, it is not legal to call any database
 * functions between dbInit and returning to the event loop.
 *
 * TODO: add return value
 */
UINT16 
db_dbInit (void)
{
  char   buffer[10+DB_keyLen];
  UINT32 id;
  int    i;

  db_serviceMode = FALSE;
  db_saveDataMode = FALSE;

  refHashTable = (RecordPtr*) OSConnectorAlloc(sizeof(RecordPtr) * DB_refHashSize);
  db_root = (RecordPtr) OSConnectorAlloc(sizeof(RecordBlock));
  #ifndef HAS_SETJMP
  if (!refHashTable || !db_root)
    return 0; /* A new event loop iteraration will cause a restart. */
  #endif
  
  db_root->next        = NULL;
  db_root->data.r      = db_root; /* BOOKMARK:FLAGS */
  db_root->flags       = DB_flag_rec | DB_flag_key | DB_flag_writeThrough | DB_flag_dataChild;
  db_root->ref         = DB_root;
  db_root->nextRec     = NULL;

  *(db_root->key + 0 ) = 'r';
  *(db_root->key + 1 ) = 'o';
  *(db_root->key + 2 ) = 'o';
  *(db_root->key + 3 ) = 't';
  *(db_root->key + 4 ) = '\0';

  ((RecordBlockPtr)db_root)->blockId    = 1024;

  for (i=0; i<DB_refHashSize; i++) 
    refHashTable[i] = NULL;
  refHashTable[DB_root & DB_refHashMask] = db_root;

  currentRef = DB_null;

  if (!Storage_Init(&store, DATABASE_STORAGESIZE, (ReadFunction*)  MEMa_readDatabase,
                   (WriteFunction*) MEMa_writeDatabase))
    return 0;

  if (! db_loadDB_wt()) {
    /* First time or start-up failure */

    *(UINT16*) (buffer + 8) = db_root->flags;
    *(UINT32*) (buffer + 0) = 0; /* Next id */
    *(UINT32*) (buffer + 4) = 0; /* Child id */

    *(BYTE*) (buffer + 10) = 'r';
    *(BYTE*) (buffer + 11) = 'o';
    *(BYTE*) (buffer + 12) = 'o';
    *(BYTE*) (buffer + 13) = 't';
    *(BYTE*) (buffer + 14) = '\0';

    id = 1024;
    Storage_AllocateBlock(&store, 10+DB_keyLen, &id);
    Storage_Put(&store, id, 0, 10+DB_keyLen, buffer);
  }

  db_loadDB_bu();

  return 0;
}



/*
 * Deletes the database content and frees all static structures.
 *
 * Remove of all non-database structures connected to the
 * database first. 
 */
UINT16 
db_dbTerminate (void)
{
  db_serviceMode = TRUE;
  db_saveDB_bu();

  db_deleteContent(db_root, FALSE);
  OSConnectorFree(db_root);

  OSConnectorFree(refHashTable);

  Storage_Finalize(&store);

  return 0;
}



/* ============================================ */
/* =======  persistent memory handling  ======= */
/* =======        write-through         ======= */
/* ============================================ */


/* 
  STRUCTURE

  Structure of write-through blocks at presistet memory:

   type   structure[size bytes]
   ---------------------------------
   rec 
   set    nextId[4] childBlockId[4] flags[2] key[DB_keyLen] 

   int    nextId[4] data[4]         flags[2] key[DB_keyLen] 

   str
   mem    nextId[4] dataLength[4]   flags[2] key[DB_keyLen] data[dataLength]


  If the DB_flag_key is not set, the key field is missing.

  The processor endian will affect the byte order within each
  field, but not the functionality.

  There is no type corresponding to pointer fields! The pointers
  point to structures outside of the database and the system has
  been restarted. They make no sense and are unsafe. Convert the
  pointer to an integer and save it as an integer element if
  using write-through elements. 

  Elements are save in reversed order. The first element in each
  list is placed last when saved. This is faster and makes it
  easier to reconstruct the structure when rebuilding.

  The flag DB_flag_lastElement is not updated for the persistent
  copy since it uses its own structure. The flag is reconstructed
  when the copy is read.


  FUNCTIONS

  This module contains four main functions:

  db_deleteElement_wt   Remove the block on persistent memory pointed
                        out by the 'blockId' field. Called from
                        db_deleteElement.

  db_saveElement_wt     Save an element to prestent memory. Called from
                        db_createNewElement and db_createNewRecord.

  db_rebuildDB_wt       Read database from presistent memory and
                        recreate it. Called by db_loadDB_wt.

  db_loadDB_wt          Trigger recreation of database. Called by
                        db_dbInit.


*/



/*
 * Return blockId field of 'element'.
 */
static UINT32 
db_getBlockId (ElementPtr element)
{
  if ((element->flags & DB_mask_dataUse) == DB_flag_dataChild)
    return ((RecordBlockPtr) element)->blockId;
  else
    if (element->flags & DB_mask_key)
      return ((FieldBlockPtr) element)->blockId;
    else
      return ((ElementBlockPtr) element)->blockId;
}



/*
 * Delete a write-through block. If 'prev_wt' is NULL, 'current'
 * is first in list and the record block conncted to 'parent' is
 * updated instead. 'prev' must point to previous write-through
 * element.
 */
static void 
db_deleteElement_wt (RecordPtr parent, ElementPtr current, ElementPtr prev)
{
  ElementPtr nextElem;
  UINT32 nextId;

  if (parent == db_root) {
    /* Cannot trust prev to point out an write-through element at root level, recalculate */
    prev = db_findPrev_wt(current);
    /* Search for next write-through element. */
    for (nextElem = current->next; nextElem != (ElementPtr) parent;
                                                      nextElem = nextElem->next)
      if (nextElem->flags & DB_mask_writeThrough)
        break;
  } else
    nextElem = current->next;

  if (prev == NULL)
    nextId = 0;
  else
    nextId = db_getBlockId(prev);

  if (nextElem == (ElementPtr) parent) /* = head in the reversed persistent list */
    DB_SET_CHILD_ID(((RecordBlockPtr) parent)->blockId, nextId)
  else
    DB_SET_NEXT_ID(nextElem, nextId)

  Storage_DeleteBlock(&store, db_getBlockId(current));
}



/*
 * Save an element marked as write-through to persistent memory.
 *
 * If element->blockId == 0, then this is the first time this 
 * element is saved. A new id then is allocated and set.
 *
 * Return TRUE if successful.
 */
static BOOL 
db_saveElement_wt (RecordPtr parent, ElementPtr element, ElementPtr prev)
{
  char buffer[10+DB_keyLen];

  ElementPtr tempElem;
  ElementPtr nextElem;

  UINT32     id;
  UINT32     nextId;
  UINT32     newId;
  UINT32     childId;
  UINT32     len;
  UINT32     dataLen;
  UINT32     blockLen;

  UINT16     type    = element->flags & DB_mask_type;
  UINT16     dataUse = element->flags & DB_mask_dataUse;
  UINT16     keyLen  = (element->flags & DB_mask_key) ? DB_keyLen : 0;

  /* block len */
  len = 10 + keyLen;
  if (type == DB_flag_str) {
    dataLen = strlen((char*) element->data.s) + 1;
    len += dataLen;
  } else if (type == DB_flag_mem) {
    dataLen = *(UINT16*) element->data.p;
    len += dataLen;
  }
  
  /* Allocate block */
  id = db_getBlockId(element);

  if (id == 0) { /* First time */
    newId = 0;
    if (! Storage_AllocateBlock(&store, len, &newId))
      /* Out of persistent memory */
      return FALSE;
  } else { 
    blockLen = Storage_GetBlockSize(&store, id);
    if (len <= blockLen && len > blockLen - 8) { /* Rounded up, 8 byte alignment */
      /* Reuse block */
      newId = id;
    } else {
      /* New block */
      newId = 0;
      if (! Storage_AllocateBlock(&store, len, &newId))
        /* Out of persistent memory */
        return FALSE;
    }
  }

  if (parent == db_root)
    /* Cannot trust prev to point out an write-through element at root level, recalculate */
    prev = db_findPrev_wt(element);
  if (prev == NULL)
    nextId = 0;
  else
    nextId = db_getBlockId(prev);

  *(UINT32*) (buffer+0) = nextId;
  *(UINT16*) (buffer+8) = element->flags;

  
  /* Set data (buffer+4) */
  if (dataUse == DB_flag_dataChild) { /* rec, set */
    if (((RecordPtr) element)->data.e == element)
      childId = 0;
    else {
      /* End element is head in the reversed persistent list */
      for (tempElem = ((RecordPtr) element)->data.e; tempElem != element;
                                                           tempElem = tempElem->next)
        prev = tempElem;
      childId = db_getBlockId(prev);
    }
    *(UINT32*) (buffer+4) = childId;
  } else if (dataUse == DB_flag_dataInternal) /* int */
    *(UINT32*) (buffer+4) = element->data.i;
  else /* str, mem */
    *(UINT32*) (buffer+4) = len;
  
  if (keyLen != 0)
    memcpy(buffer+10, ((FieldPtr) element)->key, DB_keyLen);
  Storage_Put(&store, newId, 0, 10 + keyLen, buffer);
  
  if (dataUse == DB_flag_dataExternal)
    Storage_Put(&store, newId, 10 + keyLen, dataLen, element->data.p);


  /* Insert into list in persistent memory */
  if (newId != id) {
    /* Find next write-through element in the same list as 'element'. */
    if (parent == db_root) {
      /* At top level, not all elements are write-through. Search for
       * next write-through element. */
      for (nextElem = element->next; nextElem != (ElementPtr) parent; 
                                           nextElem = nextElem->next)
        if (nextElem->flags & DB_mask_writeThrough)
          break;
    } else
      nextElem = element->next;

    if (nextElem == (ElementPtr) parent)/* End element is head in the reversed persistent list */
      DB_SET_CHILD_ID(((RecordBlockPtr) parent)->blockId, newId)
    else
      DB_SET_NEXT_ID(nextElem, newId)

    if (id != 0)
      Storage_DeleteBlock(&store, id);
  }


  /* Update blockId */
  if (dataUse == DB_flag_dataChild)
    ((RecordBlockPtr) element)->blockId = newId;
  else
    if (keyLen != 0)
      ((FieldBlockPtr) element)->blockId = newId;
    else 
      ((ElementBlockPtr) element)->blockId = newId;
  return TRUE;
}



/*
 * Rebuilds database by reading write-through data. Recursive;
 * adds fields to an already existing record.
 *
 * 'parent' is a reference to the record corresponding to the
 * parent of 'id'.
 *
 * If the function returns FALSE, the reconstruction has failed
 * and the database has only been partially reconstructed.
 */
static BOOL 
db_rebuildDB_wt (UINT32 id, DB_ref parent)
{
  BYTE   buf[BUFSIZE];
  DataUnion  data;
  ElementPtr element;
  DB_ref     newRef;
  BYTE*      key;
  UINT32     blockLen;
  UINT32     offset;
  UINT32     readLen;
  UINT32     nextId;
  UINT16     flags;
  UINT8      error;

  while (id != 0) {
    blockLen = Storage_GetBlockSize(&store, id); /* blockLen rounded up */
    readLen = MIN(BUFSIZE, blockLen);

    Storage_Get(&store, id, 0, readLen, buf);

    nextId = *(UINT32*) (buf + 0);
    flags  = *(UINT16*) (buf + 8);
    /* DB_flag_lastElement contains trash value. It is recalculated
     * in db_setItem, db_createRecord. */
    
    if (flags & DB_mask_key) {
      key = buf + 10;
      offset = 10 + DB_keyLen;
    } else
      offset = 10;

    switch (flags & DB_mask_dataUse) {
    case DB_flag_dataChild:
      newRef = db_createRecord(parent, key, flags, &error);
      if (error)
        return FALSE;
      ((RecordBlockPtr) currentRecord)->blockId = id;
      if ( ! db_rebuildDB_wt(*(UINT32*)(buf + 4), newRef))
        return FALSE;
      goto Next_iteration;

    case DB_flag_dataExternal:
      blockLen = *(UINT32*) (buf + 4); /* Exact blockLen */
      readLen = MIN(BUFSIZE, blockLen);
      data.s = (BYTE*) OSConnectorAlloc(blockLen - offset);
      #ifndef HAS_SETJMP
      if (data.s == NULL)
        return FALSE;
      #endif
      memcpy(data.s, buf + offset, (size_t)(readLen - offset));
      if (readLen < blockLen)
        Storage_Get(&store, id, readLen, blockLen - readLen, data.s + readLen - offset);
      element = db_setItem(parent, key, flags, data, &error);
      if (error) {
        OSConnectorFree(data.s);
        return FALSE;
      }
      break;

    case DB_flag_dataInternal:
      data.i = *(UINT32*) (buf + 4);
      element = db_setItem(parent, key, flags, data, &error);
      if (error)
        return FALSE;
      break;
    }
    if (flags & DB_mask_key) {
      ((FieldBlockPtr) element)->blockId   = id;
    } else {
      ((ElementBlockPtr) element)->blockId   = id;
    }
Next_iteration:
    db_markId(id);
    id = nextId;
  }
  return TRUE;
}



/*
 * Load database from persistent memory and rebuld structure.
 * Only elements saved as write-through are recovered.
 *
 * Return FALSE if there is nothing to load.
 */
static BOOL 
db_loadDB_wt (void)
{
  UINT32  id;
  UINT16  len;
  BOOL    clearAll = FALSE;
  int     i;

  if (! Storage_GetAllBlockIds(&store, &idArr, &len) || len == 0)
    return FALSE;
  
  db_serviceMode = TRUE; /* Turn of write-through while rebulding */
  Storage_Get(&store, 1024, 4, 4, &id);
  db_markId(1024);

  if (! db_rebuildDB_wt(id, DB_root)) {
    /* Rebuild has failed. Delete everything. */
    db_clearRecord(db_root->ref);
    clearAll = TRUE;
  }
  
  db_serviceMode = FALSE;

  for (i=0; i < len; i++) {
    if ((idArr[i] <= 0x80000000 || clearAll) && idArr[i] > 1024) {
      /* Found a loose block */
      Storage_DeleteBlock(&store, idArr[i] & 0x7fffffff);
    }
  }

  OSConnectorFree(idArr);
  return ! clearAll;
}


/* ============================================ */
/* =======  persistent memory handling  ======= */
/* =======            backup            ======= */
/* ============================================ */

/*

  When saving the elements, the persistent flags of the flags field are reused. The DB_flag_backup must be set
  and DB_flag_writeThrough must be cleared. This means they can be used for storing other information when
  saving, since these flags can be reconstructed when the database is reloaded.

  FUNCTIONS

  This module contains four main functions:
  
  db_writeData_bu
  db_rebuildDB_bu
  db_saveDB_bu
  db_loadDB_bu

*/

/*
 *
 *
 */
static void 
db_writeDB_bu (wap_cvt_t* obj)
{
  ElementPtr current;
  ElementPtr nextCurrent;
  BYTE*      s;
  UINT16     flags;
  UINT16     len;
  short      direction;
  short      nextDirection;
  short      level;
  short      offset;

  level = 0;
  current = db_root->data.e;
  direction = GOING_DOWN;
  while (current != (ElementPtr) db_root) {
    if (! (current->flags & DB_mask_backup)) { /* Only save backup element subtrees */
      current = current->next;
      continue;
    }
    
    /* Calculate next element */
    if (direction != GOING_UP && (current->flags & DB_mask_dataUse) == DB_flag_dataChild &&
                                                                 current->data.e != current) {
      nextDirection = GOING_DOWN;
      nextCurrent = current->data.e;
      offset = 1;
    } else {
      if (current->flags & DB_mask_lastElement) {
        nextDirection = GOING_UP;
        offset = -1;
      } else {
        nextDirection = GOING_RIGHT;
        offset = 0;
      }

      nextCurrent = current->next;
    }
        
    /* Save element */
    if (direction != GOING_UP) {
      /* Write flags */
      flags = current->flags & ~ (DB_mask_backup | DB_mask_lastElement | DB_mask_lastElement2) |
              (nextDirection == GOING_DOWN ? DB_flag_hasChild : 0) |
              (current->flags & DB_flag_lastElement ? DB_flag_lastElement2 : 0) |
              (level == 0 ? DB_flag_rootLevel : 0);
              /* Set DB_flag_hasChild if next element is a child and
               * copy DB_flag_lastElement to DB_flag_lastElement2.
               * See comment in db_rebuildDB_bu for use of
               * DB_flag_lastElement2. DB_flag_rootLevel is set on root
               * level.
               *
               * DB_flag_hasChild and DB_flag_rootLevel are temprary flags,
               * reusing other flags. See definitions. */
      wap_cvt_uint16(obj, &flags);

      /* Write key */
      if (current->flags & DB_mask_key)
        wap_cvt_static_bytevector(obj, DB_keyLen, ((FieldPtr) current)->key);

      /* Write data */
      if ((current->flags & DB_mask_dataUse) != DB_flag_dataChild) {
        if ((current->flags & DB_mask_type) == DB_flag_int) {   /* int */
            wap_cvt_uint32(obj, &current->data.i);
        } else {
          if ((current->flags & DB_mask_type) == DB_flag_str) { /* str */
            len = strlen((char*) current->data.s) + 1;
            s = current->data.s;
          } else {                                              /* mem */
            len = *(UINT16*) current->data.s - 2;
            s = current->data.s + 2;
          }
          wap_cvt_uint16(obj, &len);
          wap_cvt_static_bytevector(obj, len, s);
        }
      }
    }

    /* Move to next element */
    direction = nextDirection;
    current = nextCurrent;
    level += offset;
  }
}



/*
 *
 */
void 
db_saveDB_bu (void)
{
  BYTE*     buf;
  wap_cvt_t obj;
  UINT32    id;
  UINT16    wt = DB_flag_endOfBuffer;

  wap_cvt_init(&obj, WAP_CVT_ENCODE_SIZE, NULL, 0);
  db_writeDB_bu(&obj);
  if (obj.pos == 0)
    return;

  buf = OSConnectorAlloc(obj.pos + 2);
  #ifndef HAS_SETJMP
  if (buf == NULL)
    return;
  #endif

  wap_cvt_init(&obj, WAP_CVT_ENCODE, buf, obj.pos + 2);
  db_writeDB_bu(&obj);
  wap_cvt_uint16(&obj, &wt);

  id = 1023;
  Storage_DeleteBlock(&store, id);
  Storage_AllocateBlock(&store, obj.pos, &id);
  Storage_Put(&store, 1023, 0, obj.pos, buf);
  OSConnectorFree(buf);
}



/*
 * Rebuilds database by reading backup data. Recursive;
 * adds fields to an already existing record.
 *
 * If the function returns FALSE, the reconstruction has failed
 * and the database has only been partially reconstructed.
 */
static BOOL 
db_rebuildDB_bu (void)
{
  ElementPtr toElement;
  ElementPtr newElement;
  RecordPtr  toRec;
  BYTE*      buf;
  wap_cvt_t  obj;
  DataUnion  data;
  UINT32     size;
  short      direction;
  UINT8      error;
  BOOL       skipSubtree;

  UINT16     len;
  UINT16     flags;
  BYTE       key[DB_keyLen];

  size = Storage_GetBlockSize(&store, 1023);
  buf = OSConnectorAlloc(size);
  Storage_Get(&store, 1023, 0, size, buf);
  wap_cvt_init(&obj, WAP_CVT_DECODE, buf, size);
  
  toRec       = db_root;
  toElement   = (ElementPtr) toRec;
  direction   = GOING_DOWN;
  skipSubtree = FALSE;

  while (TRUE) {
    /* Load element */
    if (direction != GOING_UP) {

      /* Read flags */
      wap_cvt_uint16(&obj, &flags);
      if (flags & DB_mask_endOfBuffer) 
        break;
      if (flags & DB_mask_rootLevel)
        skipSubtree = FALSE; /* Turn skipping off, if on; subtree finished. */

      /* Read key */
      if (flags & DB_mask_key) {
        wap_cvt_static_bytevector(&obj, DB_keyLen, key);
        if (flags & DB_mask_rootLevel) {
          currentRef = DB_root;
          currentRecord = db_root;
          if (db_findField (key) != NULL)
            skipSubtree = TRUE; /* A record with the same name has been saved
                                 * using write-through after the backup. The
                                 * other copy is newer, use it instead. */
        }
      }


      /* Create and add new element */
      if (skipSubtree) {
        if ((flags & DB_mask_dataUse) == DB_flag_dataExternal) {
          wap_cvt_uint16(&obj, &len);
          obj.pos += len;
        } else if ((flags & DB_mask_type) == DB_flag_int)
          obj.pos += 4;
        continue;
      }

      if ((flags & DB_mask_dataUse) == DB_flag_dataChild) /* -------  rec, set */
        newElement = (ElementPtr) db_createNewRecord(toRec, key, flags,
                                      direction == GOING_DOWN ? NULL : toElement, &error);
      else { /* ----------------------------------------------------  int, str, mem */
        /* Read data */
        if ((flags & DB_mask_type) == DB_flag_int)                /* int */
          wap_cvt_uint32(&obj, &data.i);
        else {
          wap_cvt_uint16(&obj, &len);
          if ((flags & DB_mask_type) == DB_flag_mem) {            /* mem */
            obj.pos -= 2; /* The length is to be included in the copy */
            len += 2;
          }
          wap_cvt_bytevector(&obj, len, &data.s);
          if ((flags & DB_mask_type) == DB_flag_mem) {            /* mem */
            *(UINT16*) data.s = len; /* Maybe different endian */
          }
        }

        newElement = db_createNewElement(toRec, key, flags, data,
                                      direction == GOING_DOWN ? NULL : toElement, NULL, &error);
      }

      if (error != DB_err_success)
        return FALSE;

      toElement = newElement;
    }

    /* Move to next element */
    if (direction != GOING_UP && flags & DB_mask_hasChild) {
      direction = GOING_DOWN;
      toRec = (RecordPtr) toElement;
    } else {
      if (! (toElement->flags & DB_mask_lastElement2) || toRec == db_root) {
        /* Note: check lastElement2 instead of lastElement since
         * lastElement is recalculated in db_createNewRecord
         * and db_createNewElement. lastElement2 is what is found
         * on persistent memory, lastElement is the current status.*/
        direction = GOING_RIGHT;
      } else {
        direction = GOING_UP;
        toElement = toElement->next;
        toRec = (RecordPtr) toRec->next;
      }
    }
  }


  OSConnectorFree(buf);
  return TRUE;
}



/*
 * Load database from persistent memory and rebuld structure.
 * Only elements saved as backup are recovered.
 *
 * Return FALSE if there is nothing to load.
 */
static BOOL 
db_loadDB_bu (void)
{
  int dummy;

  if (! Storage_Get(&store, 1023, 0, 0, &dummy))
    return FALSE;
  if (! db_rebuildDB_bu()) {
  }
  return FALSE;
}


