/*+MHDR*/
/*
# clearcase: CmicroPatchRel2.3.3
+------------------------------------------------------------------------------+
|  Headerfile : ML_TYP.H                                                       |
|  Author       : S&P Media GmbH Germany                                       |
+------------------------------------------------------------------------------+
|                                                                              |
|  Description :                                                               |
|  This Header-file is to be included from SDL-Applications and handwritten    |
|  Code by the user. Furthermore, the Cmicro Kernel includes the file.         |
|                                                                              |
|  For more information, see next pages.                                       |
|  For detailed description, see manual.                                       |
|                                                                              |
+------------------------------------------------------------------------------+
|                                                                              |
|  Copyright by Telelogic AB 1993 - 1998                                       |
|  Copyright by S&P Media GmbH Germany 1993 - 1998                             |
|                                                                              |
|  This Program is owned by Telelogic and is protected by national             |
|  copyright laws and international copyright treaties. Telelogic              |
|  grants you the right to use this Program on one computer or in              |
|  one local computer network at any one time.                                 |
|  Under this License you may only modify the source code for the purpose      |
|  of adapting it to your environment. You must reproduce and include          |
|  any copyright and trademark notices on all copies of the source code.       |
|  You may not use, copy, merge, modify or transfer the Program except as      |
|  provided in this License.                                                   |
|  Telelogic does not warrant that the Program will meet your                  |
|  requirements or that the operation of the Program will be                   |
|  uninterrupted and error free. You are solely responsible that the           |
|  selection of the Program and the modification of the source code            |
|  will achieve your intended results and that the results are actually        |
|  obtained.                                                                   |
|                                                                              |
+------------------------------------------------------------------------------+
*/


#ifndef __ML_TYP_H_
#define __ML_TYP_H_

/*
FILE INDEX
SS0  User Section    - User - scaling facilities
AA0  Automatic scaling facilities
00   Utility macros
01   Main User oriented ifdef's
02   Dependent ifdef 's
03   C Library
03a  C Compiler section 
03b  Final setting 
04   SDL Model macro expansions
05   Utility ifdef 's
06   Constants
07   Forward Declarations
08   SDL predefined types (except SDL_PId)
09   SDL_PId
10   Signal Set
11   Procedure ( = Prd )
12   Process ( = Prs )
13   Timer
14   Signal
15   Symbol Table
16   Global Data Structure
221  _sche
222  _queu
223  _time
224  _stim
225  _err
226  _outp
227  _user
228  _main
229  Cmicro Tester
*/


/****+***************************************************************
SS0  User Section - User - scaling facilities
********************************************************************/
/* The following file is to be filled up by the users.       */
/* Do your manual scalings here ...                          */
#include "ml_mcfw.h"

/****+***************************************************************
AA0  Automatic scaling facilities
********************************************************************/
/* The following file is automatically generated by          */
/* the Cmicro-C-Codegenerator                                */
/*                                                           */
/* CAUTION :                                                 */
/* ----------                                                */
/* Be sure, that you use the correct sdl_cfg.h, because this */
/* File has the same name for all possible SDL-Systems.      */


#if !defined(SDTMT) && !defined(SDTGATE)
  #include "sdl_cfgw.h"
#endif



#ifdef XMK_USE_NO_AUTO_SCALING
  #ifdef   XMK_USED_ONLY_X_1
    /*
    ** Setting this flag cause the Cmicro Tester
    ** to produce erroneus outputs (type xPID) ...
    */
    #undef XMK_USED_ONLY_X_1
  #endif

  #define XMK_USED_TIMER
  #define XMK_USED_DYNAMIC_CREATE
  #define XMK_USED_DYNAMIC_STOP
  #define XMK_USED_SAVE
  #define XMK_USED_SIGNAL_WITH_PARAMS
  /* NOT #define XMK_USED_TIMER_WITH_PARAMS */
  #define XMK_USED_SENDER
  #define XMK_USED_OFFSPRING
  #define XMK_USED_PARENT
  #define XMK_USED_SELF
#endif

#ifdef XMK_USED_TIMER
  #define XMK_USE_TIMER_MODEL1
#endif

#ifndef XSCT_CMICRO
/*
** This define is necessary to distinguish between
** the codegenerators, especially for predefined sorts
** in the files sctpred*
*/
#define XSCT_CMICRO
#endif

/*
** The standard duration and time algorithm from Cadvanced cannot be used
** for Cmicro because limitations in timer module.
*/
#ifdef  XMK_USE_STANDARD_DURATION
#undef  XMK_USE_STANDARD_DURATION
#endif
#ifdef  XMK_USE_STANDARD_TIME
#undef  XMK_USE_STANDARD_TIME
#endif

/****+***************************************************************
00   Utility macros
********************************************************************/

#define COMMENT(P)
   /* to be used for inserting comments in in-line C-code in SDL. */
   /* the syntax is:  COMMENT(( your free format comment text ))   */

/*
** General purpose ....
*/
#ifndef XMK_OKAY
  #define XMK_OKAY      0
#endif

#ifndef XMK_ERROR
  #define XMK_ERROR     1
#endif

#ifndef XMK_AMBIGOUS 
  #define XMK_AMBIGOUS  2
#endif

#ifndef XMK_EMPTY 
  #define XMK_EMPTY     3
#endif

#define XMK_NO_PROCESS xNULLPID

#define XMK_NO_SIGNAL  0xff

#define XMK_NO_STATE   0xff


/*
** Switches
*/
#define XMK_ON     1
#define XMK_OFF    0

/*
** Modes for the Cmicro Recorder
**
** The user can use these values to set the
** appropriate recorder mode in xmk_SetRecorderMode ()
*/
#define XMK_RECORDER_OFF     0        /* no activity from Cmicro Recorder   */
#define XMK_RECORDER_RECORD  1        /* Record mode of the Cmicro Recorder */
#define XMK_RECORDER_PLAY    2        /* Play   mode of the Cmicro Recorder */

/*
** Mapping of IO (only for Cmicro Tester)
*/
#define STDERR    stderr
#define STDOUT    stdout

/*
** Host side definitions (only for Cmicro Tester)
*/
#define XMK_WAS_PRINTED_ASCII  0x0008

/*
** New macros needed for later versions of Cmicro Tester
*/
#ifdef XMK_ADD_SDLE_TRACE
  #define XAT_FIRST_SYMBOL(SYMB_NO1, SYMB_NO2) \
          xmk_TSDL_InputID( SYMB_NO2 );
  #define XBETWEEN_SYMBOLS(SYMB_NO1,SYMB_NO2,C_LINE_NO) \
          xmk_TSDL_SymbolID( SYMB_NO2 );
  #define XBETWEEN_SYMBOLS_PRD(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XBETWEEN_STMTS(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XBETWEEN_STMTS_PRD(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XAT_LAST_SYMBOL
  #define XDEBUG_LABEL(LABEL_NAME)
#else
  #define XAT_FIRST_SYMBOL(SYMB_NO1, SYMB_NO2)
  #define XBETWEEN_SYMBOLS(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XBETWEEN_SYMBOLS_PRD(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XBETWEEN_STMTS(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XBETWEEN_STMTS_PRD(SYMB_NO1,SYMB_NO2,C_LINE_NO)
  #define XAT_LAST_SYMBOL
  #define XDEBUG_LABEL(LABEL_NAME)
#endif

/*
** New macros needed for ADT support
*/
#define XCHECK_UNION_TAG(TAG,VALUE,ASSTAG,NEQTAG,COMPNAME,CURR_VALUE) \
   if (NEQTAG(TAG,VALUE)) { \
     ASSTAG(TAG,VALUE,XASS); \
   }

#define XCHECK_UNION_TAG_FREE(TAG,VALUE,ASSTAG,NEQTAG,FREEFUNC,COMPNAME,CURR_VALUE) \
   if (NEQTAG(TAG,VALUE)) { \
     FREEFUNC((void **)&(TAG)); \
     ASSTAG(TAG,VALUE,XASS); \
   }

#define XCHECK_UNION_TAG_USAGE(TAG,VALUE,NEQTAG,COMPNAME,CURR_VALUE)

#define XCHECK_OPTIONAL_USAGE(PRESENT_VAR,COMPNAME)

#define XSET_CHOICE_TAG(TAG,VALUE,ASSTAG,NEQTAG,COMPNAME,CURR_VALUE) \
   if (NEQTAG(TAG,VALUE)) { \
     ASSTAG(TAG,VALUE,XASS); \
   }

#define XSET_CHOICE_TAG_FREE(TAG,VALUE,ASSTAG,NEQTAG,FREEFUNC,COMPNAME,CURR_VALUE) \
   if (NEQTAG(TAG,VALUE)) { \
     FREEFUNC((void **)&(TAG)); \
     ASSTAG(TAG,VALUE,XASS); \
   }

#define XCHECK_CHOICE_USAGE(TAG,VALUE,NEQTAG,COMPNAME,CURR_VALUE)

#ifdef XMK_USE_MAX_ERR_CHECK
  #define XCHECK_REF(VALUE,SORTIDNODE,REF_SORT) \
    xmk_CheckNullPointerValue ( (void *) VALUE );

  #define XCHECK_OREF(VALUE,SORTIDNODE,REF_SORT) \
    xmk_CheckNullPointerValue ( (void *) VALUE );

  #define XCHECK_OREF2(VALUE) \
    xmk_CheckNullPointerValue ( (void *) VALUE );

  #define XCHECK_OWN(VALUE,SORTIDNODE,REF_SORT) \
    xmk_CheckNullPointerValue ( (void *) VALUE );

#else
  #define XCHECK_REF(VALUE,SORTIDNODE,REF_SORT)
  #define XCHECK_OREF(VALUE,SORTIDNODE,REF_SORT)
  #define XCHECK_OREF2(VALUE)
  #define XCHECK_OWN(VALUE,SORTIDNODE,REF_SORT)
#endif

/****+***************************************************************
01   Main User oriented #ifdef
********************************************************************/

/****+***************************************************************
02   Dependent #ifdef
********************************************************************/
/*---+---------------------------------------------------------------
     Check automatically generated #ifdef
-------------------------------------------------------------------*/
#if defined(XMK_IFC_TIME) && defined(XMK_C_TIME)
  #if XMK_IFC_TIME != XMK_C_TIME
    /*
    ** If the following line is compiled/leads to an error during  
    ** compilation, then the generated systemname.ifc file does not match with
    ** the generated systemname.c file. You should newly generate C code
    ** and be sure that each of the generated C files and the symbolfile
    ** is used appropriately
    */
    #error "ERROR_IllegalFileConfiguration_ifc_and_c_file_See_ml_typ.h"
  #endif
#endif

#if defined(XMK_C_TIME) && defined(XMK_CFG_TIME)
  #if XMK_C_TIME != XMK_CFG_TIME
    /*
    ** If the following line is compiled/leads to an error during  
    ** compilation, then the generated systemname.c file does not match with
    ** the generated sdl_cfg.h file. You should newly generate C code
    ** and be sure that each of the generated C files and the symbolfile
    ** is used appropriately
    */
    #error "ERROR_IllegalFileConfiguration_c_and_sdl_cfg_file_See_ml_typ.h"
  #endif
#endif

#if defined(XMK_IFC_TIME) && defined(XMK_CFG_TIME)
  #if XMK_IFC_TIME != XMK_CFG_TIME
    /*
    ** If the following line is compiled/leads to an error during  
    ** compilation, then the generated systemname.ifc file does not match with
    ** the generated sdl_cfg.h file. You should newly generate C code
    ** and be sure that each of the generated C files and the symbolfile
    ** is used appropriately
    */
    #error "ERROR_IllegalFileConfiguration_ifc_and_sdl_cfg_file_See_ml_typ.h"
  #endif
#endif

#if defined(XMK_HIGHEST_SIGNAL_NR) && !defined(XMK_USE_MORE_THAN_250_SIGNALS)
  #if XMK_HIGHEST_SIGNAL_NR > 250
    /*
    ** If the following line is compiled/leads to an error during
    ** compilation, then the amount of signals in the SDL system
    ** exceeds 250 and the define XMK_USE_MORE_THAN_250_SIGNALS should
    ** be set. Otherwise there would be runtime errors because
    ** more than 250 signals cannot be represented with an char 
    ** value (the last values are reserved for internal purposes),
    ** but must be represented with an int value.
    */
    #error "ERROR_IllegalCodingOfSignalIdentification_See_ml_typ.h"
  #endif
#endif

#if defined(XMK_USED_PWOS) && defined(XMK_USE_KERNEL_INIT)
  /*
  ** Variables, that are local in an SDL procedure need
  ** to be initialized by setting an default value.
  ** (using xDef_SDL_<typename> macros.
  ** If XMK_USE_KERNEL_INIT is defined, then process variables
  ** are set appropriately to their default values, because
  ** the Cmicro Kernel does handle initialization of data during
  ** process creation.  But, if procedures are used, then the 
  ** defaultsetting of variable cannot be ensured, because the 
  ** variables are initialized at procedure startup with 
  ** the same method as process variables are initialized.
  ** In general, XMK_USE_KERNEL_INIT is more efficient than explicitely
  ** setting default values variable per variable.
  ** On the other hand, difficulties may arise if variables in an SDL
  ** procedure are not initialized before using them.
  */
  #define XMK_USE_PROCEDURE_INIT /* or set to #undef */

  #ifdef XMK_USE_PROCEDURE_INIT
    /*
    ** The most safest way is however to undefine XMK_USE_KERNEL_INIT
    ** when procedures are used.
    */
    #undef XMK_USE_KERNEL_INIT
  #else
    /*
    ** Remove this error message below if you don't need Default
    ** Setting in procedures.
    */
    #error "ERROR_NoDefaultValueForVariablesInProcedures_See_ml_typ.h"
  #endif
#endif /* ... defined(XMK_USE_PWOS) && defined(XMK_USE_KERNEL_INIT) */

/*---+---------------------------------------------------------------
     Dependent user oriented #ifdef
-------------------------------------------------------------------*/

#if !defined(SDTMT) && !defined(SDTGATE)
#ifndef  XMK_USE_SENDER_PID_IN_SIGNAL
  #ifdef   XMK_USED_SENDER
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_01"
  #endif

  #ifdef   XMK_USED_PARENT
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_02"
  #endif
#endif


#ifndef  XMK_USE_RECEIVER_PID_IN_SIGNAL
  #ifdef   XMK_USE_PREEMPTIVE
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_03"
  #endif

  #ifdef   XMK_USE_TIMESLICE
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_04"
  #endif

  #ifdef   XMK_USED_DYNAMIC_CREATE
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_05"
  #endif

  #ifndef   XMK_USED_ONLY_X_1
     #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_06"
  #endif
#endif


/* in case of  undef  : SDL-Addressing not available         */
/* in case of  define : SDL-Addressing is  available         */

/*
** Note:XMK_USE_PID_ADDRESSING is used in generated C code !
*/
#if defined(XMK_USED_PARENT) || defined(XMK_USED_OFFSPRING)
  #define XMK_USE_PID_ADDRESSING
#endif


#ifdef  XMK_ADD_PRINTF
  /*
  ** For each C-Module there is s separate printf
  */
  #define XMK_ADD_PRINTF_KERNEL
  #define XMK_ADD_PRINTF_LIBRARY
  #define XMK_ADD_PRINTF_TESTER
  #define XMK_ADD_PRINTF_SDL
  #define XMK_ADD_PRINTF_ADDITIONAL
  #define XMK_USE_MON
#endif



#ifdef XMK_ADD_PRINTF_KERNEL
  #define XMK_ADD_PRINTF_CPU
  #define XMK_ADD_PRINTF_MAIN
  #define XMK_ADD_PRINTF_OUTPUT
  #define XMK_ADD_PRINTF_QUEUE
  #define XMK_ADD_PRINTF_SCHEDULER
  #define XMK_ADD_PRINTF_TIMER
  #define XMK_ADD_PRINTF_USER
#endif



#ifdef XMK_ADD_PRINTF_LIBRARY
  #define XMK_ADD_PRINTF_COD
  #define XMK_ADD_PRINTF_DL
  #define XMK_ADD_PRINTF_COM
  #define XMK_ADD_PRINTF_ERROR
  #define XMK_ADD_PRINTF_MONITOR
  #define XMK_ADD_PRINTF_MEMORY
  #define XMK_ADD_PRINTF_PREDEFINED
#endif



#ifdef XMK_ADD_PRINTF_TESTER
  #define XMK_ADD_PRINTF_RUL
  #define XMK_ADD_PRINTF_OPT
  #define XMK_ADD_PRINTF_RING
  #define XMK_ADD_PRINTF_TSDL
  #define XMK_ADD_PRINTF_TSYS
  #define XMK_ADD_PRINTF_REC
  #define XMK_ADD_PRINTF_PLAY
#endif

#endif /* ... ! defined(SDTMT) && !defined(SDTGATE) */

/*
** -----------------------------------------------------------------
** Overall control over allowed configurations
** -----------------------------------------------------------------
*/

#ifndef XMK_ADD_MICRO_TESTER
  /*
  ** Per default, it is not allowed to use any part 
  ** of the Cmicro Tester, without using the Cmicro Tester itself.
  */
  #ifdef XMK_USE_DISTRIBUTED
  #undef XMK_USE_DISTRIBUTED
  #endif
  #ifdef XMK_ADD_MICRO_RECORDER
  #undef XMK_ADD_MICRO_RECORDER
  #endif
  #ifdef XMK_ADD_MICRO_COMMAND
  #undef XMK_ADD_MICRO_COMMAND
  #endif
  #ifdef XMK_USE_DEBUGGING
  #undef XMK_USE_DEBUGGING
  #endif
  #ifdef XMK_ADD_PROFILE
  #undef XMK_ADD_PROFILE
  #endif
  #ifdef XMK_ADD_TRACE_BUF
  #undef XMK_ADD_TRACE_BUF
  #endif
  #ifdef XMK_ADD_MICRO_TRACER
  #undef XMK_ADD_MICRO_TRACER
  #endif
  #ifdef XMK_ADD_SDLE_TRACE
  #undef XMK_ADD_SDLE_TRACE
  #endif
  #ifdef XMK_ADD_PSC_TRACE
  #undef XMK_ADD_PSC_TRACE
  #endif
  #ifdef XMK_ADD_MICRO_RECORDER
  #undef XMK_ADD_MICRO_RECORDER
  #endif
  #ifdef XMK_ADD_SIGNAL_FILTER
  #undef XMK_ADD_SIGNAL_FILTER
  #endif
  #ifdef XMK_ADD_STDOUT_TRACE
  #undef XMK_ADD_STDOUT_TRACE
  #endif
  #ifdef XMK_ADD_FILE_TRACE
  #undef XMK_ADD_FILE_TRACE
  #endif
  #ifdef XMK_USE_COMMLINK
  #undef XMK_USE_COMMLINK
  #endif
#endif /* ... XMK_ADD_MICRO_TESTER */

/*
** -----------------------------------------------------------------
** Control of Cmicro Kernel configuration
** -----------------------------------------------------------------
*/
#if defined(XMK_USE_PREEMPTIVE) && defined(XMK_USE_NO_RECURSION)
  /*
  ** Caution : The Cmicro Kernel uses recursion, if it
  ** is scaled preemptive !
  */
  #error "ERROR_in_ml_typ.h\IllegalCombinationOfDefines_12"
#endif

#if defined(XSYSID)
  /*
  ** If Partitioning is used
  */
  #if defined(XMK_USE_PREEMPTIVE)
    /*
    ** Caution : Preemption cannot be used together
    ** with Partitioning !
    */
    #error "ERROR_in_ml_typ.h\PreemptionNotAllowedWithPartitioning"
  #endif

  /*
  ** Over-define macro
  */
  #define XMAKENAME(P1,P2)  XCAT(P1,P2)

  /*
  ** main function in mk_main module cannot be used because
  ** users have to initialize the several systems by hand.
  ** For all partitions, first xmk_InitQueue, then xmk_InitSDL
  ** must be called. After each xmk_InitSDL is called, xmk_RunSDL
  ** might be called.
  */
  #ifndef  XNOMAIN
    #define XNOMAIN
  #endif

  /*
  **  Rename global variables and tables from User C code
  */
  #ifndef XMK_NO_REENTRANCY_PROBLEM
/*
GBU 990729  Modified since we don't want ErrorHandler when XMK_USE_NO_ERR_CHECK is defined.
*/
/*
//  GBU 990409  ErrorHandler already exists in OSE.
//    #define ErrorHandler                        XMAKENAME(XSYSID,ErrorHandler)
    #define ErrorHandler                        XMAKENAME(XSYSID,cmicroErrorHandler)
*/
    #ifndef XMK_USE_NO_ERR_CHECK
        #define ErrorHandler                        XMAKENAME(XSYSID,cmicroErrorHandler)
    #else
        #define ErrorHandler(errnum)
    #endif
    #define xmk_InitSystime                     XMAKENAME(XSYSID,InitializeSystemTime)
    #define xmk_SetTime                         XMAKENAME(XSYSID,SetSystemTime)
    #define xmk_NOW                             XMAKENAME(XSYSID,GetSystemTime)
    #define xAlloc                              XMAKENAME(XSYSID,OSalloc)
    #define xFree                               XMAKENAME(XSYSID,OSfree)
    #define xAlloc_SDL_Bit_String               XMAKENAME(XSYSID,AllocSDLBitstring)
    #define xFree_SDL_Bit_String                XMAKENAME(XSYSID,FreeSDLBitstring)
    #define xAlloc_SDL_Charstring               XMAKENAME(XSYSID,AllocSDLCharstring)
    #define xFree_SDL_Charstring                XMAKENAME(XSYSID,FreeSDLCharstring)
  #endif /* XMK_NO_REENTRANCY_PROBLEM */

  /*
  **  Rename global variables and tables from generated C code
  */
  #define yInit                               XMAKENAME(XSYSID,yInit)
  #define xPDTBL                              XMAKENAME(XSYSID,RootPrsTableVar)

  /*
  **  Rename environment functions
  */
  #define xInitEnv                            XMAKENAME(XSYSID,xInitEnv)
  #define xInEnv                              XMAKENAME(XSYSID,xInEnv)
  #define xOutEnv                             XMAKENAME(XSYSID,xOutEnv)
  #define xCloseEnv                           XMAKENAME(XSYSID,xCloseEnv)

  /*
  **  Rename global variables and tables from Cmicro Kernel
  */
  #define xRunPID                             XMAKENAME(XSYSID,RunPIDVar)
  #define pRunData                            XMAKENAME(XSYSID,RunDataPtr)
  #define pRunPIDTable                        XMAKENAME(XSYSID,RunPIDTablePtr)
  #define xmk_EmptySignalVar                  XMAKENAME(XSYSID,EmptySignalVar)
  #define xmk_SymbolNrVar                     XMAKENAME(XSYSID,SymbolNrVar)
  #define xmk_SignalInstPtr                   XMAKENAME(XSYSID,SignalInstPtr)
  #define xmk_SignalArrayVar                  XMAKENAME(XSYSID,SignalArrayVar)
  #define xmk_FreeListPointer                 XMAKENAME(XSYSID,FreeListPtr)
  #define xmk_Queue                           XMAKENAME(XSYSID,QueueVar)
  #define xmk_CurrentSignal                   XMAKENAME(XSYSID,CurrentSignalPtr)
  #define xmk_InterruptsDisabled              XMAKENAME(XSYSID,InterruptsDisabled)
  #define xmk_InitState                       XMAKENAME(XSYSID,QueueInitState)
  #define xmk_TimerArrayVar                   XMAKENAME(XSYSID,TimerArray)
  #define xmk_PassiveTimerPtr                 XMAKENAME(XSYSID,PassiveTimerPtr)
  #define xmk_ActiveTimerPtr                  XMAKENAME(XSYSID,ActiveTimerPtr)

  /*
  **  Rename global variables and tables from C Library
  **  Users must take care upon implementation
  **  and especially the problem of reentrancy for these functions.
  */
  #define xSDLOpError                         XMAKENAME(XSYSID,xSDLOpError)

  #ifndef XMK_NO_REENTRANCY_PROBLEM
    #define fprintf                             XMAKENAME(XSYSID,fprintf)
    #define printf                              XMAKENAME(XSYSID,printf)
  #endif /* ... XMK_NO_REENTRANCY_PROBLEM */

#else
  #define XMAKENAME(P1,P2)  P2

/*
GBU 990729  Added since we don't want ErrorHandler when XMK_USE_NO_ERR_CHECK is defined.
*/
    #ifdef XMK_USE_NO_ERR_CHECK
        #define ErrorHandler(errnum)
    #endif

#endif /* ... defined(XSYSID) && defined(XMK_USE_PREEMPTIVE) */


/*
** -----------------------------------------------------------------
** Control of internal functions
** -----------------------------------------------------------------
*/
#ifdef XMK_USE_SDL_MEM
  #define XMK_USE_memshrink
  #define XMK_USE_memset
  #define XMK_USE_memcpy
#endif


/****+***************************************************************
03   C Library
********************************************************************/

/* General */
#ifdef XNOPROTO
  #define PROTO(x)  ()
  #define XMK_B
  #define XMK_E
  #define XCAT(P1,P2)     P1/**/P2
  #define XPP_PROTO(P)
  #define XPP_NOPROTO(P)  P
#else
  #define PROTO(x)  x
  #define XMK_B     {
  #define XMK_E     }
  #define XCAT(P1,P2)     P1##P2
  #define XPP_PROTO(P)    P
  #define XPP_NOPROTO(P)
#endif

#ifndef XMK_VOID
  #define XMK_VOID  (void)
#endif

/*
** Define XCONST as const, if the compiler in use supports "const"
** This is only the default setting for XCONST ...
*/
#define XCONST  const

/* Define X_REGISTER register, if the compiler in use has good support
** for register ...
*/
#define X_REGISTER

/*
** Define X_STATIC as static, if the compiler  / target in use
** has more static RAM than stack memory ...
*/
#define X_STATIC

/*
** Define XMK_END_CRITICAL_PATH and XMK_BEGIN_CRITICAL_PATH per default empty ...
** These macros are used to lock critical pathes in
** the Cmicro Kernel not only for preemption.
** The definition of these ias absolutely
** necessary if interrupts are used ...
*/
#define XMK_END_CRITICAL_PATH
#define XMK_BEGIN_CRITICAL_PATH


/*
** The intention of the following define
** is to suppress warnings of the compiler
** like "<ident> never used", which come
** in a few sections, where the user is free
** to use such variables or not
*/
#define XMK_SUPPRESS(variable)

#ifndef xmk_T_ERR_NUM
  /*
  ** Error numbering, may also be char, if numbering is within the
  ** range of 1 .... 250
  */
  #define xmk_T_ERR_NUM int
#endif

#ifndef xmk_OPT_INT
  /*
  ** Loop counters, result values and some other variables within the
  ** Cmicro Kernel can be defined as char, or as int. It depends just on
  ** the machine in use, what should be defined behind this macro.
  ** For instance, a 8051
  ** produces a lot of overhead for int, long and pointer variables.
  ** On the other hand, some machines, like 68xxx produce more code, if
  ** they should handle char, instead of int. Define xmk_OPT_INT as what
  ** you want to in your compiler section or on the compiler command line
  ** or whatever.
  */
  #define xmk_OPT_INT int
#endif

/*
** For Controllers in Harvard architecture (e.g. Intel 8051) several
** variables can be stored in internal or external RAM/ROM.
** For  controllers in 'von Neumann' architecture the following macros
** have to be defines as follows:
*/
#define xmk_ROM_ptr  *
#define xmk_RAM_ptr  *


#ifndef XMK_KERNEL_EXIT
  #define XMK_KERNEL_EXIT(x)
#endif

/*
** default  for path and filename separation, for Unix versions
*/
#define XMK_PATH_SEPARATION_CHAR '/'  /* path/filename for unix */

/*
** Size of one char value in octet
*/
#define XMK_SIZEOF_CHAR 1

#ifdef  XMK_UNIX
#undef  XMK_UNIX
#endif

/****+***************************************************************
03a   C Compilersection begins
********************************************************************/

/*---+---------------------------------------------------------------
     UNIX: GNU C COMPILER
-------------------------------------------------------------------*/
#if defined(_GCC_)
#error  _GCC__removed_by_GBU_990512
/* ... defined(_GCC_) */

/*---+---------------------------------------------------------------
     Windows: Microsoft C++ compiler
-------------------------------------------------------------------*/
#elif defined(MICROSOFT_C)
#error  MICROSOFT_C_removed_by_GBU_990512
/* ... MICROSOFT_C */

/*---+---------------------------------------------------------------
     Windows: BORLAND C++ compiler
-------------------------------------------------------------------*/
#elif defined(BORLAND_C)
#error  BORLAND_C_removed_by_GBU_990512
/* ... BORLAND_C */

/*---+---------------------------------------------------------------
     DOS: MSP58C80
-------------------------------------------------------------------*/
#elif defined(MSP58C80)
#error  MSP58C80_removed_by_GBU_990512
/* ... MSP58C80 */

/*---+---------------------------------------------------------------
     UNIX/DOS: IARC51
-------------------------------------------------------------------*/
#elif defined(IARC51)
#error  IARC51_removed_by_GBU_990512
/* ... IARC51 */

/*---+---------------------------------------------------------------
     DOS: KEIL_C51
-------------------------------------------------------------------*/
#elif defined(KEIL_C51)
#error  KEIL_C51_removed_by_GBU_990512
/* ... KEIL_C51 */

/*---+---------------------------------------------------------------
     DOS: KEIL_C166
-------------------------------------------------------------------*/
#elif defined(KEIL_C166)
#error  KEIL_C166_removed_by_GBU_990512
/* ... KEIL_C166 */

/*---+---------------------------------------------------------------
     UNIX: GNU 80166
-------------------------------------------------------------------*/
#elif defined(GNU80166)
#error  GNU80166_removed_by_GBU_990512
/* ... GNU80166 */

/*---+---------------------------------------------------------------
     MS-DOS: MCC68K
-------------------------------------------------------------------*/
#elif defined(MCC68K)
#error  MCC68K_removed_by_GBU_990512
/* ... MCC68K */

/*---+---------------------------------------------------------------
     DOS: Tasking 80166
-------------------------------------------------------------------*/
#elif defined(TCC80166)
#error  TCC80166_removed_by_GBU_990512
/* ... TCC80166 */

/*-------------------------------------------------------------------
     DOS: BSO/TASKING 80196
-------------------------------------------------------------------*/
#elif defined(TCC80C196)
#error  TCC80C196_removed_by_GBU_990512
/* ... TCC80C196 */

/*---+---------------------------------------------------------------
     DOS: IAR Compiler for Melps 7700
-------------------------------------------------------------------*/
#elif defined(IARC7700)
#error  IARC7700_removed_by_GBU_990512
/* ... IARC7700 */

/*---+---------------------------------------------------------------
     DOS: HYPERSTONE
-------------------------------------------------------------------*/
#elif defined(HYPERSTONE)
#error  HYPERSTONE_removed_by_GBU_990512
/* ... HYPERSTONE */

/*---+---------------------------------------------------------------
     DOS: IAR C Compiler for Hitachi 6301 MPU family types
-------------------------------------------------------------------*/
#elif defined(IARC6301)
#error  IARC6301_removed_by_GBU_990512
/* ... IARC6301 */

/*---+---------------------------------------------------------------
     DOS: Thumb C Compiler for the ARM Processor
-------------------------------------------------------------------*/
#elif defined(ARM_THUMB)
#error  ARM_THUMB_removed_by_GBU_990512
/* ... ARM_THUMB */

/*---+---------------------------------------------------------------
      GREEN_HILLS
-------------------------------------------------------------------*/
#elif  defined (GREEN_HILLS)
#error  GREEN_HILLS_removed_by_GBU_990512
/* ... GREEN_HILLS */

/*---+---------------------------------------------------------------
     Any User defined C Compiler
-------------------------------------------------------------------*/
#else

  /*
  ** If no C compiler is defined from the above list , then users
  ** may add their own C compiler in their own description file
  ** user_cc.h. The file should contain
  **
  ** #ifdef C_compiler_abbreviation
  **   ...user definitions (use any compiler above as a template) ...
  ** #endif
  */
/*  Removed by GBU,000215   The filer "user_cc.h" is not used any longer. The code is inserted below.
  #include "user_cc.h"
*/


#include "ansilibs.h"
#include "tapicmmn.h"


#undef X_REGISTER
/* Define X_REGISTER register, if the compiler in use has good support
** for register ...
*/
#define X_REGISTER register

#undef X_STATIC
/*
** Define X_STATIC as static, if the compiler  / target in use
** has more static RAM than stack memory ...
*/
#define X_STATIC static

#undef xmk_OPT_INT
/*
** Loop counters, result values and some other variables within the
** Cmicro Kernel can be defined as char, or as int. It depends just on
** the machine in use, what should be defined behind this macro.
** For instance, a 8051
** produces a lot of overhead for int, long and pointer variables.
** On the other hand, some machines, like 68xxx produce more code, if
** they should handle char, instead of int. Define xmk_OPT_INT as what
** you want to in your compiler section or on the compiler command line
** or whatever.
*/
#define xmk_OPT_INT int

#undef xmk_ROM_ptr
#undef xmk_RAM_ptr
/*
** For Controllers in Harvard architecture (e.g. Intel 8051) several
** variables can be stored in internal or external RAM/ROM.
** For  controllers in 'von Neumann' architecture the following macros
** have to be defines as follows:
*/
#define xmk_ROM_ptr  *
#define xmk_RAM_ptr  *


/*---+---------------------------------------------------------------
**      Timer implementation is now done in timers.c.
**      Certain macros in ml_typ.h must therefore be redefined
**-----------------------------------------------------------------*/

#undef XMK_USE_TIMER_MODEL1

#define DEF_TIMER_VAR(NAME)
#define INIT_TIMER_VAR(TIMER_VAR)
#define INPUT_TIMER_VAR(TIMER_VAR)
#define RELEASE_TIMER_VAR(TIMER_VAR)
#define SDL_NOW 0

#define SDL_SET(TIME_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
    xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);

#define SDL_SET_DUR(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
    xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);

#define SDL_SET_TICKS(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
    xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);

#define SDL_RESET(TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
    xmk_TimerReset(TIMER_IDNODE);


void xmk_TimerSet( long, unsigned int);

#define SET_TIMER_WITH_PARAM(TIME_EXPR, TIMER_IDNODE, TIMER_ID) \
    TimerWithParamSet(TIME_EXPR,TIMER_IDNODE, TIMER_ID);

#define RESET_TIMER_WITH_PARAM(TIMER_IDNODE, TIMER_ID) \
    TimerWithParamReset(TIMER_IDNODE, TIMER_ID);

/*---+---------------------------------------------------------------
**      Misc
**-----------------------------------------------------------------*/

#undef  XMK_KERNEL_EXIT
#define XMK_KERNEL_EXIT(x)

#define XPP(x) x

#define INT_MAX 2147483647 /* INT32 */

#define xptrint UINT32
#define xint32 INT32


#endif /* ... of all C compiler - defines */

/****+***************************************************************
      C Compilersection ends
********************************************************************/

/*---+---------------------------------------------------------------
03b   Final setting
-------------------------------------------------------------------*/

/*
** Define PROTO as XPP is defined, for
** compatibility with previous releases
*/
#undef  PROTO
#define PROTO(x)  XPP(x)

#ifdef  XMK_ADD_STDIO
  /*
  ** If Cmicro is used on a host machine (or a machine which
  ** is like a host, e.g. supports printf, argc/argv when calling main)
  ** then use the template xmk_printf function
  */
  extern int xmk_printf ( char* format, ...);
#endif /* ... XMK_ADD_STDIO */

/*
** Size of an integer value. It is assumed to have 32 Bits in integers.
** If this is not true, the users should redefine the INT_MAX value
** depending on the C compiler by using
** #ifdef INT_MAX
** #undef INT_MAX
** #endif
** In the following, a max value of an "int" for 16 Bit is shown
** #define INT_MAX         32767
** In the following, a max value of an "int" for 32 Bit is shown
** #define INT_MAX         2147483647
*/
#ifndef INT_MAX
#define INT_MAX         2147483647      /* max value of an "int" for 32 Bit */
#endif

/*
** The max.value of an integer usually is defined in the limits.h
** header file from the C compiler.
**
** In the following, a max value of an "int" for 16 Bit is shown
** #define xMax_SDL_Integer         32767
** In the following, a max value of an "int" for 32 Bit is shown
** #define xMax_SDL_Integer         2147483647
*/
#ifdef  INT_MAX
#define xMax_SDL_Integer INT_MAX
#else
#define xMax_SDL_Integer 2147483647
#endif


/****+***************************************************************
04   SDL Model macro expansions
********************************************************************/

/* General defines */
#ifndef xmk_T_BOOL
  #if !defined(X_COMPACT_BOOL)
    #define xmk_T_BOOL int
    #define xbool      int
  #else
    #define xmk_T_BOOL char
    #define xbool      char
  #endif

  #define XMK_TRUE                1
  #define XMK_FALSE               0

  #define XMK_WAIT                2
  #define XMK_IGNORE              3

  #define XMK_REQUEST_FROM_UI     4
  #define XMK_RECOVERY            5

  #define XMK_START_BATCH         6

  #define XMK_NO_CONFIRMATION     7

#endif /* ... xmk_T_BOOL */

#ifndef NULL
#define NULL  ((void*)0)
#endif

#if !defined(SDTMT)
  #include "sctpred.h"
#endif

#define XMK_EOF     -1

#define XMK_CTRL_C      0x03        /* ctrl-c          */
#define XMK_CTRL_D      0x04        /* ctrl-d          */
#define XMK_CTRL_H      0x08        /* ctrl-h          */
#define XMK_CTRL_Q      0x11        /* ctrl-q          */
#define XMK_CTRL_U      0x15        /* ctrl-u          */
#define XMK_LF          0x0a        /* Line feed       */
#define XMK_CR          0x0d        /* Carriage return */
#define XMK_ESC         0x1b        /* Escape          */
#define XMK_XON         0x11        /* Start    */
#define XMK_XOFF        0x13        /* Stop     */


#define XMK_CTRL_BACKSP XMK_CTRL_H  /* backspace       */

#define XMK_TERMINATION_CHAR(chr) ((c==XMK_CTRL_D) || (c==XMK_CTRL_Q))

#define XMK_IS_PRINTABLE_CHAR(chr) ((c>=0x20) || (c==XMK_CTRL_H))


#ifdef  XMK_CREATE_SIGNALID
    #undef  XMK_CREATE_SIGNALID
#endif
#if !defined(XMK_USE_MORE_THAN_250_SIGNALS) && !defined(SDTMT)
  #define XMK_CREATE_SIGNALID         255
  typedef unsigned char xmk_T_SIGNAL      ;/* Type of signal-id's  */
#else
  #define XMK_CREATE_SIGNALID         32767
  typedef unsigned int  xmk_T_SIGNAL      ;/* Type of signal-id's  */
#endif


typedef unsigned char xmk_T_PROCESS     ;/* Type f.processtypes  */
typedef unsigned char xmk_T_INSTANCE    ;/* Type f.processinst.  */


#if defined(XMK_USE_HUGE_TRANSITIONTABLES) || defined(SDTMT)
  #define XMK_NO_ASTERISK 32767
  typedef          int  xmk_T_OFFSET      ;/* State index table for huge systems */
  typedef unsigned int  xSYMBOLNR         ;/* Symbol-Number for      */
                                           /* yPAD-Function for huge */
  typedef unsigned int  xSTATE            ;/* Process-State          */
  typedef unsigned int  xmk_T_STATE       ;/* SDL-Process state  !! Same as xSTATE !!  */
#else
  #define XMK_NO_ASTERISK 255
  typedef unsigned char xmk_T_OFFSET      ;/* State index table for tiny systems */
  typedef unsigned char xSYMBOLNR         ;/* Symbol-Number for      */
                                           /* yPAD-Function for tiny */
  typedef unsigned char xSTATE            ;/* Process-State          */
  typedef unsigned char xmk_T_STATE       ;/* SDL-Process state  !! Same as xSTATE !!  */
#endif /* ... XMK_USE_HUGE_TRANSITIONTABLES */

typedef unsigned char xmk_T_PRIO        ;/* Type for priority    */
typedef unsigned char xmk_T_PRIOLEVEL   ;/* Type for priolevel   */
typedef unsigned long xmk_T_TIME        ;/* Type for SDL time    */



#if !defined(XMK_USE_PAR_GREATER_THAN_250) && !defined(SDTMT)
  typedef unsigned char xmk_T_MESS_LENGTH ;/* Signal.par.length    */
#else
  typedef unsigned int  xmk_T_MESS_LENGTH ;/* Signal.par.length    */
#endif

#ifdef XMK_USE_PREEMPTIVE
  typedef xSTATE      ( *xmk_T_TRANS_ADDRESS ) XPP(( xSYMBOLNR )) ;
#else
  typedef xSTATE      ( *xmk_T_TRANS_ADDRESS ) XPP(( void )) ;
#endif

/* ---------------- Variables in the PAD function ---------------- */

#define PROCESS_VARS                    unsigned char _dummy_var;

#define YPAD_TEMP_VARS \
        unsigned char xmk_RAM_ptr xmk_OutputSignalPtr;


#define YPAD_YSVARP \
        unsigned char xmk_RAM_ptr ySVarP;

/*
** Used for two different signals in one input symbol
*/
#define INSIGNAL_NAME         xmk_SignalInstPtr ->signal
#define SIGNAL_NAME(p1,p2)    p2

#define YPAD_YVARP(VDEF_TYPE)                         \
        VDEF_TYPE     xmk_RAM_ptr yVarP =(VDEF_TYPE xmk_RAM_ptr ) pRunData;

#define YGLOBALPRD_YVARP


#ifdef  XMK_USED_SELF
#define SDL_SELF                        xRunPID
#endif

#ifdef  XMK_USED_SENDER

/*
** Use safe PID addressing when SENDER is to be checked
** in starttransition. This costs some RAM/ROM/Performance
** and might be left out if it is for sure, that no
** start transition tries to access "SENDER".
*/
#define XMK_USE_SAFE_ADDRESSING
#define SDL_SENDER                      xmk_SignalInstPtr ->send
#endif

#ifdef  XMK_USED_PARENT
  #define SDL_PARENT                      pRunPIDTable->Parent
#endif

#ifdef  XMK_USED_OFFSPRING
  #define SDL_OFFSPRING                   pRunPIDTable->Offspring
#endif


#define CURRENT_STATE_PRD               ProceduresWithStatesNotImplemented

/* ------------------ Structure of PAD function ------------------ */

#define YPAD_RESULT_TYPE                         xSTATE

#ifdef  XMK_USE_PREEMPTIVE
  #ifndef XNOPROTO
    /* Preemption - ANSI */
    #define YPAD_PROTOTYPE(functionname)           xSTATE functionname (xSYMBOLNR xmk_SymbolNrVar);
    #define YPAD_FUNCTION(functionname)            xSTATE functionname (xSYMBOLNR xmk_SymbolNrVar)
  #else
    /* Preemption - Kernighan / Ritchie */
    #define YPAD_PROTOTYPE(functionname)           xSTATE functionname ();
    #define YPAD_FUNCTION(functionname) \
            xSTATE functionname (xmk_SymbolNrVar) \
            xSYMBOLNR xmk_SymbolNrVar;
  #endif
#else
  #ifndef XNOPROTO
    /* No Preemption - ANSI */
    #define YPAD_PROTOTYPE(functionname)           xSTATE functionname (void);
    #define YPAD_FUNCTION(functionname)            xSTATE functionname (void)
  #else
    /* No Preemption - Kernighan / Ritchie */
    #define YPAD_PROTOTYPE(functionname)           xSTATE functionname ();
    #define YPAD_FUNCTION(functionname) \
            xSTATE functionname (xmk_SymbolNrVar) \
            xSYMBOLNR xmk_SymbolNrVar;
  #endif
#endif

#ifdef XMK_USED_SIGNAL_WITH_PARAMS

  #if (XMK_MSG_BORDER_LEN==0)

    #define BEGIN_PAD \
            if (xmk_SignalInstPtr  != NULL ) \
            { /* if not start transition */ \
              if (xmk_SignalInstPtr ->mess_length > XMK_MSG_BORDER_LEN) \
              { ySVarP = (unsigned char xmk_RAM_ptr ) xmk_SignalInstPtr ->ParUnion.ParPtr; \
              } \
            }


  #else

    #define BEGIN_PAD \
            if (xmk_SignalInstPtr  != NULL ) \
            { /* if not start transition */ \
              if (xmk_SignalInstPtr ->mess_length > XMK_MSG_BORDER_LEN) \
              { ySVarP = (unsigned char xmk_RAM_ptr ) xmk_SignalInstPtr ->ParUnion.ParPtr; } \
              else { ySVarP = (unsigned char xmk_RAM_ptr ) xmk_SignalInstPtr ->ParUnion.ParCopy; } \
            }


  #endif

#else

    #define BEGIN_PAD

#endif


#ifdef XMK_USE_END_PAD
  /*
  ** Pay attention to the following define, if
  ** you do tied integration in your target ....
  ** Compilers produce a warning, if no return is found
  ** at the end of an yPAD_Function
  */
  #define END_PAD(VTYPE)  \
          return (XDASHSTATE) ;
#else
/*
GBU 991104  at least one compiler wants a return expression
a zero has not caused any problems in previous versions
*/  
/*
  #define END_PAD(VTYPE)
*/
  #define END_PAD(VTYPE)  \
          return 0;
#endif


#define XSYMBOLNUMBER                           xmk_SymbolNrVar

#ifdef XMK_ADD_STDIO

        /* CAUTION :                                     */
        /* ------------                                  */
        /* DO NOT USE PRINTF IN THE CASE OF A SO SCALED  */
        /* PREEMPTIVE Cmicro Kernel, IF YOU ARE NOT SURE,*/
        /* THAT fprintf () IS IMPLEMENTED REENTRANT BY   */
        /* THE COMPILER IN USE !!!                       */

        #define PRINTF(params)   (void)xmk_printf params;
        #define XMK_DEBUG
#else
        #define PRINTF(params)
#endif


/*
** Cmicro Tester
*/
#ifdef  XMK_ADD_MICRO_TESTER
        #define XTRACE
        #define XMK_TEST_TASK(p1)      xmk_TSDL_Task(p1);
        #define XMK_TEST_DECISION(p1)  xmk_TSDL_Decision(p1);
        #define XMK_TEST_PROCEDURE(p1) xmk_TSDL_Procedure(p1);
#else
        #define XMK_TEST_TASK(p1)
        #define XMK_TEST_DECISION(p1)
        #define XMK_TEST_PROCEDURE(p1)
#endif


/*
** Execution- Trace
*/

#ifdef XMK_ADD_PRINTF_SDL
  #define BEGIN_START_TRANSITION \
          PRINTF(("START-TRANSITION\n"));

  #define PRINTF_OUTPUT(P1) \
          PRINTF(("OUTPUT: %s\n", P1));

  #define PRINTF_CREATE(P1)  \
          PRINTF(("CREATE: %s\n", P1));

  #define YPRSNAME_VAR(PRS_NAME_STRING) \
          PRINTF(("PROCESS: %s\n", PRS_NAME_STRING));

  #define XOS_TRACE_INPUT(SIG_NAME_STRING) \
          PRINTF(("INPUT: %s\n", SIG_NAME_STRING));

  #define YPRDNAME_VAR(PRD_NAME_STRING) \
          PRINTF(("PROCEDURE %s\n", PRD_NAME_STRING)); \
          XMK_TEST_PROCEDURE (PRD_NAME_STRING);

  #define xTraceTask(P1) \
          PRINTF(("TASK: %s\n", P1)); \
          XMK_TEST_TASK((P1));

  #define xTraceAssign(P1) \
          PRINTF(("ASSIGN: %s\n", P1)); \
          XMK_TEST_TASK((P1));

  #define xTraceAlg(P1) \
          PRINTF(("ALG: %s\n", P1)); \
          XMK_TEST_TASK((P1));

  #define xTraceDecision(P1) \
          PRINTF(("DECISION: %s\n", P1 )); \
          XMK_TEST_DECISION(( P1 ));

  #define XOS_TRACE_NEXTSTATE(P1) \
          PRINTF(("Nextstate: %d\n",  P1 ));

  #define XOS_TRACE_DASHSTATE \
          PRINTF(("No state change\n" ));

#else

  #define BEGIN_START_TRANSITION

  #define PRINTF_OUTPUT(P1)

  #define PRINTF_CREATE(P1)

  #define YPRSNAME_VAR(PRS_NAME_STRING)

  #define XOS_TRACE_INPUT(SIG_NAME_STRING)

  #define YPRDNAME_VAR(PRD_NAME_STRING) \
          XMK_TEST_PROCEDURE(PRD_NAME_STRING);

  #define xTraceTask(P1) \
          XMK_TEST_TASK((P1));

  #define xTraceAssign(P1) xTraceTask(P1)

  #define xTraceAlg(P1)    xTraceTask(P1)

  #define xTraceDecision(P1) \
          XMK_TEST_DECISION(( P1 ));

  #define XOS_TRACE_NEXTSTATE(P1)

  #define XOS_TRACE_DASHSTATE

#endif


#if  defined(XMK_ADD_PRINTF_SDL) \
  || defined(XMK_ADD_PRINTF_ADDITIONAL) \
  || defined(XMK_ADD_PRINTF_CPU) \
  || defined(XMK_ADD_PRINTF_MAIN) \
  || defined(XMK_ADD_PRINTF_OUTPUT) \
  || defined(XMK_ADD_PRINTF_QUEUE) \
  || defined(XMK_ADD_PRINTF_SCHEDULER) \
  || defined(XMK_ADD_PRINTF_TIMER) \
  || defined(XMK_ADD_PRINTF_USER) \
  || defined(XMK_ADD_PRINTF_COM) \
  || defined(XMK_ADD_PRINTF_ERROR) \
  || defined(XMK_ADD_PRINTF_MONITOR) \
  || defined(XMK_ADD_PRINTF_MEMORY) \
  || defined(XMK_ADD_PRINTF_PREDEFINED)

  #define XMK_FUNCTION(p1) \
          PRINTF(("FUNCTION: %s\n", p1));
  #define XMK_TRACE_SCHE(p1)  \
          PRINTF(("mk_sche: %s\n", p1));
  #define XMK_TRACE_EXIT(p1) \
          PRINTF(("Exit from %s\n", p1));
#else
  #define XMK_FUNCTION(p1)
  #define XMK_TRACE_SCHE(p1)
  #define XMK_TRACE_EXIT(p1)
#endif

/* ------------------------ yInit function ----------------------- */
extern void yInit XPP((void));

/* ------------------ Actions within transitions ----------------- */
/*
** Mapping the SDL_Halt () into xCloseEnv ()
*/
#define SDL_Halt()      xCloseEnv ()

/* ---------------------------- Output --------------------------- */

#define SIGNAL_VARS

#define ALLOC_SIGNAL(SIG_NAME, SIG_IDNODE, RECEIVER, SIG_PAR_SIZE) \
        { SIG_IDNODE  SIG_IDNODE; \
          xmk_OutputSignalPtr = (unsigned char xmk_ROM_ptr ) &SIG_IDNODE;

#define ALLOC_SIGNAL_NPAR(SIG_NAME, SIG_IDNODE, RECEIVER)
        /* empty */

#ifndef XNOUSEOFCHARSTRING
  #define ALLOC_SIGNAL_PAR(SIG_NAME, SIG_IDNODE, SIG_PAR_TYPE)   \
          { SIG_PAR_TYPE  xmk_TmpSignalOutputBuffer ; \
            memset ((char xmk_RAM_ptr ) &xmk_TmpSignalOutputBuffer, 0, sizeof (xmk_TmpSignalOutputBuffer)); \
            xmk_OutputSignalPtr = (unsigned char xmk_RAM_ptr ) &xmk_TmpSignalOutputBuffer;
#else
  #define ALLOC_SIGNAL_PAR(SIG_NAME, SIG_IDNODE, SIG_PAR_TYPE)   \
          { SIG_PAR_TYPE  xmk_TmpSignalOutputBuffer ; \
            xmk_OutputSignalPtr = (unsigned char  xmk_RAM_ptr ) &xmk_TmpSignalOutputBuffer;
#endif

#ifndef TRANSFER_SIGNAL
#define TRANSFER_SIGNAL(SIG_NAME, SIG_IDNODE, RECEIVER, SIG_PAR_SIZE)
#endif

#define XSIGNALHEADERTYPE /* empty */

#ifndef TRANSFER_SIGNAL_PAR
#define TRANSFER_SIGNAL_PAR(SIG_NAME, SIG_IDNODE, P3) {
#endif

#ifndef TRANSFER_SIGNAL_NPAR
#define TRANSFER_SIGNAL_NPAR(SIG_NAME, SIG_IDNODE, P3)
#endif

#define SIGNAL_ALLOC_ERROR                      /* empty */
#define SIGNAL_ALLOC_ERROR_END                  }

#define OUTSIGNAL_DATA_PTR                      xmk_OutputSignalPtr

#if defined(XMK_USE_SIGNAL_PRIORITIES) && defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
  /*
  ** Each signal contains a Signal priority
  ** Each signal contains a Receiver PID
  */
  #ifdef XMK_USED_SIGNAL_WITH_PARAMS
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER);
  #else
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PRIO,RECEIVER);
  #endif
#endif

#if defined(XMK_USE_SIGNAL_PRIORITIES) && !defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
  /*
  ** Each signal contains a Signal priority
  ** No   signal contains a Receiver PID
  */
  #ifdef XMK_USED_SIGNAL_WITH_PARAMS
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR);
  #else
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PRIO);
  #endif
#endif

#if !defined(XMK_USE_SIGNAL_PRIORITIES) && defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
  /*
  ** No   signal contains a Signal priority
  ** Each signal contains a Receiver PID
  */
  #ifdef XMK_USED_SIGNAL_WITH_PARAMS
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER);
  #else
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,RECEIVER);
  #endif
#endif

#if !defined(XMK_USE_SIGNAL_PRIORITIES) && !defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
  /*
  ** No   signal contains a Signal priority
  ** No   signal contains a Receiver PID
  */
  #ifdef XMK_USED_SIGNAL_WITH_PARAMS
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE,SIG_PAR_LEN,SIG_PARA_PTR);
  #else
    #define XMK_SF(SIG_ID_NODE,SIG_PRIO,SIG_PAR_LEN,SIG_PARA_PTR,RECEIVER) \
            xmk_Send (SIG_ID_NODE);
  #endif
#endif


#define XMK_DUMMYPRIO      0xff              /* for Cmicro Tester only */


#ifdef XMK_USE_xmk_SendSimple
   /*
   ** Use simple output function when possible ...
   ** Note, that signal priorities get lost when using xmk_SendSimple Function !
   */
   #ifdef XMK_USE_RECEIVER_PID_IN_SIGNAL
     #define SDL_OUTP_NPAR(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
             PRINTF_OUTPUT(SIG_NAME_STRING); \
             xmk_SendSimple (SIG_IDNODE,RECEIVER);
   #else
     #define SDL_OUTP_NPAR(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
             PRINTF_OUTPUT(SIG_NAME_STRING); \
             xmk_SendSimple (SIG_IDNODE);
   #endif
#else
   /*
   ** No simple output function available - use complex one
   ** This output function can handle signal priorities.
   */
   #define SDL_OUTP_NPAR(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
           PRINTF_OUTPUT(SIG_NAME_STRING); \
           XMK_VOID XMK_SF(SIG_IDNODE,PRIO,0,(void xmk_RAM_ptr) NULL,RECEIVER);
#endif

#define SDL_OUTP_PAR(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
        PRINTF_OUTPUT(SIG_NAME_STRING); \
        XMK_VOID XMK_SF(SIG_IDNODE,PRIO,sizeof(NUM), \
        (void  xmk_RAM_ptr) xmk_OutputSignalPtr,RECEIVER); }

#define SDL_OUTP_NPAR_ENV(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
        PRINTF_OUTPUT(SIG_NAME_STRING); \
        XMK_VOID XMK_SF (SIG_IDNODE,PRIO,0,(void xmk_RAM_ptr) NULL,RECEIVER);

#define SDL_OUTP_PAR_ENV(PRIO,SIG_NAME,SIG_IDNODE,RECEIVER,NUM,SIG_NAME_STRING) \
        PRINTF_OUTPUT(SIG_NAME_STRING); \
        XMK_VOID XMK_SF (SIG_IDNODE,PRIO,sizeof (NUM), (void xmk_RAM_ptr) xmk_OutputSignalPtr ,RECEIVER); }

/*
** The following macro is used in SDL_OUTP - macro calls
*/
#ifndef XMK_USED_ONLY_X_1
  #define TO_PROCESS(PROC_NAME, PROC_IDNODE) \
                            xmk_Determine_Receiver(XCAT(XPTID_,PROC_IDNODE))
#else
  #define TO_PROCESS(PROC_NAME, PROC_IDNODE) XCAT(XPTID_,PROC_IDNODE)
#endif

/*
** Macro for use in the environment functions for user
** can be used in xInEnv () or in an interrupt service routine
** Main use is to send the ENV-PID to xmk_Send () ...
*/
#define XMK_SEND_ENV(ENV_ID,SIG_IDNODE,PRIO,SIG_PAR_LEN,SIG_PTR,RECEIVER) \
        xtmpPID = xRunPID ;                                               \
        xRunPID = ENV_ID ;                                                \
        XMK_SF(SIG_IDNODE,PRIO,SIG_PAR_LEN,SIG_PTR,RECEIVER);             \
        xRunPID = xtmpPID;

#define XMK_SEND_TMP_VARS    xPID xtmpPID;


/* ---------------------------- Create --------------------------- */

#define STARTUP_VARS
        /* empty */

#define ALLOC_STARTUP_NPAR(PROC_NAME, STARTUP_IDNODE, STARTUP_PAR_TYPE, XNL)
        /* empty */

/*
** Not relevant for Cmicro in SDT/Tau product release ;
*/
#define ALLOC_STARTUP(PROC_NAME, STARTUP_IDNODE, STARTUP_PAR_TYPE) \
        xmk_OutputSignalPtr = getnewmemoryfor_ALLOC_STARTUP ();

/*
** Not relevant for Cmicro in SDT/Tau product release ;
*/
#define ALLOC_STARTUP_THIS \
        xmk_OutputSignalPtr = getnewmemoryfor_ALLOC_STARTUP_THIS ();

#define STARTUP_ALLOC_ERROR
#define STARTUP_ALLOC_ERROR_END
#define STARTUP_DATA_PTR \
        xmk_OutputSignalPtr->VarP

#define SDL_CREATE(PROC_NAME, PROC_IDNODE, PROC_NAME_STRING, STARTUP_IDNODE, PRIV_DATA_TYPE, PRIO, PAD_FUNCTION) \
        PRINTF_CREATE(PROC_NAME_STRING); \
        XMK_VOID xmk_CreateProcess (XCAT(XPTID_,PROC_IDNODE));

/* ------------------------- Static Create ------------------------ */
/* Is totally done by Cmicro Kernel, via the <root-process-table>  */


/* ----------------------------- Stop ---------------------------- */
/* A stop in a SDL-Process means a return from the yPAD-Function   */
/* The Cmicro Kernel handles all further actions.                  */

#define SDL_STOP \
        return (XDORMANT);

/*
** Insert free statements when process stops
*/
#if defined(XMK_USED_DYNAMIC_STOP)
  #define XFREEVARS
#endif

/* The following Macro is inserted directly before SDL_STOP and    */
/* can be used to free () Processvariables, if wanted in special   */
/* applications ...                                                */
#ifdef XFREEVARS
    #define FREE_PROCESS_VARS
#endif



/* ---------------------------- Timers --------------------------- */

/* ----- Timermodel 1 ----- */
#ifdef XMK_USE_TIMER_MODEL1

   /* -- Definitions */
   #define DEF_TIMER_VAR(NAME)            /* unnecessary */
   #define INIT_TIMER_VAR(TIMER_VAR)      /* unnecessary */
   #define INPUT_TIMER_VAR(TIMER_VAR)     /* unnecessary */
   #define RELEASE_TIMER_VAR(TIMER_VAR)   /* unnecessary */
   #define SDL_NOW                        xmk_NOW ()


   #ifdef XMK_USE_TIMER_SCALE
     /*
     ** Here is a little help to scale timers.
     ** Timer scaling is always useful only when using the Cmicro Tester,
     ** so the accuracy is not a problem.
     */
     #define SDL_SET(TIME_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet((TIME_EXPR-SDL_NOW)*xmk_TimerScaleFactor+SDL_NOW,TIMER_IDNODE);

     #define SDL_SET_DUR(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet((TIME_EXPR-SDL_NOW)*xmk_TimerScaleFactor+SDL_NOW,TIMER_IDNODE);

     #define SDL_SET_TICKS(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet((TIME_EXPR-SDL_NOW)*xmk_TimerScaleFactor+SDL_NOW,TIMER_IDNODE);
   #else
     #define SDL_SET(TIME_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);

     #define SDL_SET_DUR(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);

     #define SDL_SET_TICKS(TIME_EXPR, DUR_EXPR, TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
             xmk_TimerSet(TIME_EXPR,TIMER_IDNODE);
   #endif

   /* -- Reset without parameters */
   #define SDL_RESET(TIMER_NAME, TIMER_IDNODE, TIMER_VAR, TIMER_NAME_STRING) \
           xmk_TimerReset(TIMER_IDNODE);

   /* -- Active (timer active) */
   #define SDL_ACTIVE(TIMER_NAME, TIMER_IDNODE, TIMER_VAR) \
           xmk_TimerActive(TIMER_IDNODE)

#endif /* ... XMK_USE_TIMER_MODEL1 */


/* ----- Timermodel 2 ----- */
#ifdef XMK_USE_TIMER_MODEL2
  /*
  ** CAUTION !
  ** ===================
  ** This timermodel 2 is not applicable for usual Cmicro Kernel
  ** Integrations. There might be some customized applications
  ** not included in Cmicro product, handling timers in a
  ** different way, but these cannot be used.
  */
  #ifdef  XMK_USE_TIMER_ROM_TABLE
    typedef struct _XTIMER_ROM_TABLE_ENTRY
    {
      xPID          Ownerprocess;
      xmk_T_SIGNAL  timer_id;
      xmk_T_TIME    timer_startval;
      unsigned int  offset;
    } XTIMER_ROM_TABLE_ENTRY ;
    #define XDEFTIMER_ROM_TABLE_ENTRY(a,b,c,d) a, b, c, d,
    #define X_END_TIMER_ROM  (xPID) 0xff
    #define MAXN                                1
  #endif /* ... XMK_USE_TIMER_ROM_TABLE */

  #ifdef  XMK_USE_TIMER_RAM_TABLE
    #define MAXI                                1
    typedef struct _XTIMER_RAM_TABLE_ENTRY
    {
      /*   xPID          Ownerprocess;  */
      /*   xmk_T_SIGNAL  timer_id;      */
           xmk_T_TIME    timer_val;
      /*   unsigned int  offset;        */
    } XTIMER_RAM_TABLE_ENTRY ;
  #endif /* ... XMK_USE_TIMER_RAM_TABLE */
#endif /* ... XMK_USE_TIMER_MODEL2 */


/* --------------------------- Nextstate ------------------------- */
#define SDL_NEXTSTATE(STATE_NAME, STATE_IDNODE, STATE_NAME_STRING)  \
        XOS_TRACE_NEXTSTATE(STATE_IDNODE); \
        return(STATE_IDNODE);

#define SDL_DASH_NEXTSTATE \
        XOS_TRACE_DASHSTATE; \
        return(XDASHSTATE);

/* --------------------------- Decision -------------------------- */
#define XDECISION_ERROR ErrorHandler (ERR_N_SDL_DECISION_ELSE);


/* --------------------------- SDL Array ------------------------- */
#define XRANGE_ERROR    ErrorHandler (ERR_N_SDL_RANGE);
#define XINDEX_ERROR    ErrorHandler (ERR_N_SDL_RANGE);

#ifdef XECSOP
  extern void xSDLOpError XPP((char*, char*));
#else
  #define xSDLOpError(p1,p2) ErrorHandler(ERR_N_PREDEFINED_OPERATOR_CALL);
#endif


/****+***************************************************************
05   Utility #ifdef
********************************************************************/
#ifndef NIL
  #define NIL 0
#endif

/****+***************************************************************
06   Constants
********************************************************************/
#define XMK_STOP              1      /* xmk_RunSDL () */
#define XMK_NORMALRETURN      0      /* xmk_RunSDL () */
#define XMK_RECORDER_TAPE_END 2      /* xmk_RunSDL () */



/****+***************************************************************
07   Forward Declarations
********************************************************************/

/****+***************************************************************
08   SDL predefined types (except SDL_PId)
********************************************************************/

/****+***************************************************************
09   SDL_PId
********************************************************************/

#define SDL_pid xPID
#define SDL_Pid xPID
#define SDL_PId xPID
#define SDL_PID xPID


#ifdef XMK_USED_ONLY_X_1
  /* Each SDL-Process in the System is defined as (1,1) or (0,1) or (,1) */
  /* +---------------------------+                                       */
  /* +    <process-type-id>      +                                       */
  /* +---------------------------+                                       */
  /* + xPID = unique process-id  +                                       */
  /* +---------------------------+                                       */
  typedef unsigned char xPID; /* char is enough to handle >250 Processes */

  #define GLOBALPID(ptype,pinst)    ptype
  #define EPIDTYPE(globalpid)       globalpid
  #define EPIDINST(globalpid)       0

  /* Reserved Values, not available for ordinary Process-type-IDs     */
  #define xNULLTYPE         0xff
  #define xNULLINST         0xff
  #define xNULLPID          0xff
  #define SDL_NULL          xNULLPID
  #define ENV               0xfe
  #define MICROKERNEL       0xfc      /* internal purposes */
  #define SET_ENVIRONMENT   xRunPID = ENV;

#else
  /* Anywhere in the System there is a process, which is not defined as */
  /* (1,1) or (0,1) or (,1)                                             */
  /* +---------------------------+------------------------+             */
  /* +     higher Byte           +  lower Byte            +             */
  /* +---------------------------+------------------------+             */
  /* +    <process-inst-id>      + <process-type-id>      +             */
  /* +---------------------------+------------------------+             */
  /* +               xPID = unique process-id             +             */
  /* +---------------------------+------------------------+             */
  typedef unsigned int  xPID;/* int  is enough to handle >250 P.types   */
                             /* and 255 Instances per Type, easy to     */
                             /* calculate                               */

  #define GLOBALPID(ptype,pinst)   ( ptype | (pinst << 8) )
  #define EPIDTYPE(globalpid)      ( (unsigned char) globalpid & 0xff)
  #define EPIDINST(globalpid)      ( (unsigned char) (globalpid >> 8) & 0xff)

  /* Reserved Value, not available for ordinary Process-type-IDs     */
  #define xNULLTYPE         0xff
  #define xNULLINST         0xff
  #define xNULLPID          0xffff
  #define SDL_NULL          xNULLPID
  #define ENV               0xfffe
  #define MICROKERNEL       0xfffc      /* internal purposes */
  #define SET_ENVIRONMENT   xRunPID = ENV;

#endif





/* if xPID is of a basic C-type like unsigned char or int  */
/* Assignment of PIDs in Process are easy .... .           */
#ifndef XMK_USED_ONLY_X_1
#define xEq_SDL_PId(pid1,pid2) (pid1==pid2)
#define xEq_SDL_PIdNULL(pid)   (pid==xNULLPID)
#define xDef_SDL_PId(V)       *(V) = xNULLPID;
#define yDef_SDL_PId(V)       xDef_SDL_PId(V)
#define yAssF_SDL_PId(V,E,A)  { V = E; }
#define yEqF_SDL_PId(E1,E2)   (E1==E2)
#define yNEqF_SDL_PId(E1,E2)  (E1!=E2)
#else
#define xEq_SDL_PId(pid1,pid2) (pid1==pid2)
#define xEq_SDL_PIdNULL(pid)   (pid==xNULLPID)
#define xDef_SDL_PId(V)       *(V) = xNULLPID;
#define yDef_SDL_PId(V)       xDef_SDL_PId(V)
#define yAssF_SDL_PId(V,E,A)  { V = E; }
#define yEqF_SDL_PId(E1,E2)   (E1==E2)
#define yNEqF_SDL_PId(E1,E2)  (E1!=E2)
#endif

#define yDef_xPID             yDef_SDL_PId
#define yAssF_xPID            yAssF_SDL_PId
#define yEqF_xPID             yEqF_SDL_PId
#define yNEqF_xPID            yNEqF_SDL_PId




/****+***************************************************************
10   Signal Set
********************************************************************/

/****+***************************************************************
11   Procedure ( = Prd )
********************************************************************/
  #define YPRD_YSVARP

  #define YPRD_TEMP_VARS \
          unsigned char *xmk_OutputSignalPtr;

  #define YPRD_YVARP(VDEF_TYPE) \
          VDEF_TYPE *yVarP = (VDEF_TYPE*) pRunData;

  /*
  ** Define the following macros outside this headerfile in tight
  ** integrations to be able to access pid expressions in global procedures
  ** like in output to (SENDER|PARENT|OFFSPRING|SELF).
  **
  ** The macros cover :
  **    -function declaration (XGP_.*P),
  **    -function call        (XGP_.*C),
  **    -function definition for ANSI C (XGP_.*D).
  **    -function definition for KR C (XGP_.*K and XGP_.*_KD).
  ** For each of the above, there is one macro for a GP with parameters (XGP_PARAM_.*)
  ** and one further macro for a GP without parameters (XGP_NOPARAM.*).
  */

  /* Global PRD with FPAR */

  #ifndef XGP_PARAM_P
    #define XGP_PARAM_P
  #endif

  #ifndef XGP_PARAM_C
    #define XGP_PARAM_C
  #endif

  #ifndef XGP_PARAM_D
    #define XGP_PARAM_D
  #endif

  #ifndef XGP_PARAM_K
    #define XGP_PARAM_K
  #endif

  #ifndef XGP_PARAM_KD
    #define XGP_PARAM_KD
  #endif

  /* Global PRD without FPAR */

  #ifndef XGP_PARAM_PE
    #define XGP_PARAM_PE
  #endif

  #ifndef XGP_PARAM_CE
    #define XGP_PARAM_CE
  #endif

  #ifndef XGP_PARAM_DE
    #define XGP_PARAM_DE
  #endif

  #ifndef XGP_PARAM_KE
    #define XGP_PARAM_KE
  #endif


/****+***************************************************************
12   Process ( = Prs )
********************************************************************/
/* The following ID is reserved and not available for ordinary SIG-ID */
#if !defined(XMK_USE_MORE_THAN_250_SIGNALS) && !defined(SDTMT)
  #define XASTERISK        (xINPUT)    253
#else
  #define XASTERISK        (xINPUT)    32765
#endif

/* The following ID is reserved and not available for Symbolnumber    */
#define XSTART_TRANSITION 0                /* Symbolnumber in yPAD-Function */

/* The following ID is reserved and not available for signals !       */
#define XUNDEF_SIGNAL     -1
#define XFIRSTSIGNALID   ((xmk_T_SIGNAL) 0x01) /* for sym - module          */

/* The following IDs   are reserved and not available for             */
/* Proces-state-values.                                               */
#ifdef XMK_USE_HUGE_TRANSITIONTABLES
  #define XSTARTUP         ((xmk_T_STATE)  0xffff) /* <process-state-table>     */
  #define XDORMANT         ((xmk_T_STATE)  0xfffc) /* <process-state-table>     */
  #define XNOTEXISTENT     ((xmk_T_STATE)  0xffff) /* for sym - module          */
  #define XFIRSTSTATEID    ((xmk_T_STATE)  0x01)   /* for sym - module          */
  #define XDASHSTATE       ((xmk_T_STATE)  0xfffe)
  #define XCREATION        ((xmk_T_STATE)  0xfffa)
  #define XSAVEID          (xSYMBOLNR)     0xfffe  /* for xSYMBOLNUMBER type    */
#else
  #define XSTARTUP         ((xmk_T_STATE)  0xff) /* <process-state-table>     */
  #define XDORMANT         ((xmk_T_STATE)  0xfc) /* <process-state-table>     */
  #define XNOTEXISTENT     ((xmk_T_STATE)  0xff) /* for sym - module          */
  #define XFIRSTSTATEID    ((xmk_T_STATE)  0x01) /* for sym - module          */
  #define XDASHSTATE       ((xmk_T_STATE)  0xfe)
  #define XCREATION        ((xmk_T_STATE)  0xfa)
  #define XSAVEID          (xSYMBOLNR)     0xfe  /* for xSYMBOLNUMBER type    */
#endif

#define X_END_ROOT_TABLE (XCONST XPDTBL xmk_ROM_ptr) 0xffff
                                         /* Table-end of <Root-Table> */

typedef unsigned char    xSTATE_INDEX;   /*                           */

#if !defined(XMK_USE_MORE_THAN_250_SIGNALS) && !defined(SDTMT)
  typedef unsigned char    xINPUT;       /*                           */
#else
  typedef unsigned int     xINPUT;       /*                           */
#endif

typedef unsigned char    xINSTD;         /*                           */
typedef unsigned short   xINSTDLEN;      /*                           */

/*
** <state-index-table>
*/
#ifdef XMK_USE_HUGE_TRANSITIONTABLES
  /*
  ** <state-index-table>  for huge systems
  */
  typedef struct
  {
    int Offset;
  } xSITBL;
#else
  /*
  ** <state-index-table>  for tiny systems
  */
  typedef struct
  {
    unsigned char Offset;
  } xSITBL;
#endif /* ... XMK_USE_HUGE_TRANSITIONTABLES */

/*
** <Transition-table>
*/
   typedef struct {
      xINPUT               SignalID;
      xSYMBOLNR            SymbolNr;
   } xTR_TABLE_ENTRY;

   typedef xTR_TABLE_ENTRY xTRTBL;



/*
** <PID-Table>
*/
#if defined(XMK_USED_PARENT) || defined(XMK_USED_OFFSPRING)
   typedef struct
   {
      #ifdef XMK_USED_PARENT
      xPID            Parent;
      #endif

      #ifdef XMK_USED_OFFSPRING
      xPID            Offspring;
      #endif

   } xPIDTable;
#endif



/*
** <Process-description-table>
*/

   typedef struct {

   #if defined(XMK_USED_PARENT) || defined(XMK_USED_OFFSPRING)
      xPIDTable       xmk_RAM_ptr pPIDTable; /* Pointer to PIDs for each */
                                             /* instance                   */
   #endif

      xINSTD          * pInstanceData ;    /* Pointer to Instancedata */
                                           /* Vector                     */
      xINSTDLEN        DataLength ;        /* Length of Instancedata     */
                                           /* for 1 Instance             */
                                           /* (used by SDL-BS)           */
      unsigned char    MaxInstances ;      /* Max.Number of Instances    */


          #ifdef XMK_USE_TIMESLICE
            /* For special form of integration not included in SDT/Tau */
            /* product release : Time slicing.                         */
            xmk_T_TIMESLICE TimeSlice;
          #endif

      #ifdef XMK_USE_PREEMPTIVE
         /* Process-Priority can be specified with #PRIO on the SDL-Level */
         /* It is available only, if the Cmicro Kernel is scaled to       */
         /* handle preemption.                                            */
         xmk_T_PRIOLEVEL PrioLevel;
      #endif

      xmk_T_TRANS_ADDRESS yPAD_Function ; /* Address of the yPAD-Function*/

      XCONST xTRTBL           xmk_ROM_ptr TransitionTable ;
      XCONST xSITBL           xmk_ROM_ptr StateIndexTable ;
      xSTATE                  xmk_RAM_ptr ProcessStateTable ;

   } XPDTBL;



/****+***************************************************************
13   Timer
********************************************************************/



/****+***************************************************************
14   Signal
********************************************************************/
typedef struct
{
   #ifdef XMK_USE_RECEIVER_PID_IN_SIGNAL
      xPID              rec;         /* Receiving process                     */
   #endif

   xmk_T_SIGNAL         signal;      /* Signalcode                            */

   #ifdef XMK_USE_SIGNAL_PRIORITIES
      xmk_T_PRIO        prio;        /* Priority                              */
   #endif

   #ifdef XMK_USE_SIGNAL_TIME_STAMP
      xmk_T_TIME        timestamp;   /* Timestamp, filled through xmk_NOW()   */
                                     /* at SDL Output                         */
   #endif

   #ifdef XMK_USE_SENDER_PID_IN_SIGNAL
      xPID              send;        /* Sending process                       */
   #endif

   #ifdef XMK_USED_SIGNAL_WITH_PARAMS
     xmk_T_MESS_LENGTH mess_length; /* Length of Signalparameters ..            */
                                    /* Assume, XMK_MSG_BORDER_LEN is 4, then :  */
                                    /* If length <= 4 Bytes: Data is copied  .. */
                                    /* .. into ParCopy ..                       */
                                    /* else, if                                 */
                                    /* .. length > 4 Bytes: Data is copied into */
                                    /* .. a malloc area, and ParPtr points to it*/
     union
     {
        void            xmk_RAM_ptr ParPtr;

        #if (XMK_MSG_BORDER_LEN > 0)
          unsigned char ParCopy[XMK_MSG_BORDER_LEN];
        #endif
     } ParUnion ;
   #endif

} xmk_T_MESSAGE;


typedef struct _T_E_SIGNAL
{
  /*
  ** Adress of a signal instance
  */
  xmk_T_MESSAGE       Signal;

  /*
  ** Pointer to successor signal instance
  */
  struct _T_E_SIGNAL xmk_RAM_ptr next;

  #ifdef XMK_USED_SAVE
    /*
    ** The state of the process when a signal is saved.
    */
    xmk_T_STATE         SaveState;
  #endif /* XMK_USED_SAVE */
} T_E_SIGNAL ;


/****+***************************************************************
15   Symbol Table
********************************************************************/


/****+***************************************************************
16   Global Data Structure
********************************************************************/
#define XASS      0
#define XASSMAKE  1
#define XASS2MAKE 2
#define XASSPARA  3
#define XASSCOPY  4 /* Used for creating local copy of fpar in in a PRD */

/****+***************************************************************
221  _sche
********************************************************************/
/* Global Variables to access PIDs , Instancedata, Inputport etc...*/
#ifndef NO_GLOBAL_VARS
  extern xPID       xRunPID ;     /* Currently active SDL-Process-   */
                                  /* Instance                        */

  #if defined(XMK_USED_PARENT) || defined(XMK_USED_OFFSPRING)
    extern xPIDTable xmk_RAM_ptr pRunPIDTable;
                                /* Table with PID-Values of        */
                                /* currently active processinst.   */
  #endif

  extern xmk_T_MESSAGE  xmk_RAM_ptr xmk_SignalInstPtr ;
                                /* Pointer to SDL-Signalparameters */
                                /* currently worked on (NULL in a  */
                                /* Start-Transition)               */

  extern xINSTD        xmk_RAM_ptr pRunData;
                                /* Pointer to Data of currently    */
                                /* running SDL-Processinstance     */

  #ifdef XMK_USE_PREEMPTIVE
    extern T_E_SIGNAL  xmk_RAM_ptr Prio_Queue[];
    extern T_E_SIGNAL  xmk_RAM_ptr Prio_CurrentSignal[];
    extern xmk_T_PRIOLEVEL HighestPrioLevel;
  #endif

#endif /* NO_GLOBAL_VARS*/

#if !defined(SDTMT) && !defined(SDTGATE)
  #include "mk_sche.h"
#endif

/****+***************************************************************
222  _queu
********************************************************************/
#ifdef XMK_USE_PREEMPTIVE

#define XMK_QUEUE_ADR xmk_Queue
#define XMK_QUEUE     xmk_RAM_ptr xmk_Queue
#define XMK_QUEUE_PTR xmk_RAM_ptr xmk_RAM_ptr xmk_Queue

#define XMK_CURRENTSIGNAL_ADR xmk_CurrentSignal
#define XMK_CURRENTSIGNAL     xmk_RAM_ptr xmk_CurrentSignal
#define XMK_CURRENTSIGNAL_PTR xmk_RAM_ptr xmk_RAM_ptr xmk_CurrentSignal

#else

#define XMK_QUEUE_ADR &xmk_Queue
#define XMK_QUEUE     xmk_Queue
#define XMK_QUEUE_PTR xmk_RAM_ptr xmk_Queue

#define XMK_CURRENTSIGNAL_ADR &xmk_CurrentSignal
#define XMK_CURRENTSIGNAL     xmk_CurrentSignal
#define XMK_CURRENTSIGNAL_PTR xmk_RAM_ptr xmk_CurrentSignal

#endif

#ifndef NO_GLOBAL_VARS
extern T_E_SIGNAL XMK_QUEUE_PTR;
extern T_E_SIGNAL XMK_CURRENTSIGNAL_PTR;
#endif

#if !defined(SDTMT) && !defined(SDTGATE)
  #include "mk_queu.h"
#endif


/****+***************************************************************
223  _time
********************************************************************/
#if !defined(SDTMT) && !defined(SDTGATE)
/*
GBU 990730  Modified since GWC uses the target timers.
*/
/*
  #include "mk_time.h"
*/
  #include "wiptimer.h"
#endif

/****+***************************************************************
224  _stim
********************************************************************/
#if !defined(SDTMT) && !defined(SDTGATE)
  extern void       xmk_InitSystime   XPP(( void )) ;
  extern void       xmk_DeinitSystime XPP(( void )) ;
  extern void       xmk_SetTime       XPP(( xmk_T_TIME )) ;
  extern xmk_T_TIME xmk_NOW           XPP(( void )) ;
#endif

/****+***************************************************************
225  _err
********************************************************************/

/****+***************************************************************
226  _outp
********************************************************************/
#if !defined(SDTMT) && !defined(SDTGATE)
  #include "mk_outp.h"
#endif

/****+***************************************************************
227  _user
********************************************************************/
#if !defined(SDTMT) && !defined(SDTGATE)

  /*
  ** SDL Environment functions to be filled out by user
  */
  extern void xInitEnv        XPP (( void ));
  extern void xCloseEnv       XPP (( void ));
  extern void xInEnv          XPP (( void ));

/*
GBU 990729  Modified since we don't want ErrorHandler when XMK_USE_NO_ERR_CHECK is defined.
*/
/*
  extern void ErrorHandler    XPP (( xmk_T_ERR_NUM ));
*/
  #ifndef XMK_USE_NO_ERR_CHECK
    extern void ErrorHandler    XPP (( xmk_T_ERR_NUM ));
  #endif
  extern void Watchdogtrigger XPP (( void ));

  #ifndef XMK_USE_RECEIVER_PID_IN_SIGNAL
    extern xPID xRouteSignal       XPP((xmk_T_SIGNAL));
  #endif

  #ifdef XMK_USED_SIGNAL_WITH_PARAMS
    #define XOUTP_PARA_NON_LAST xmk_T_MESS_LENGTH,void *,
    #define XOUTP_PARA_LAST     xmk_T_MESS_LENGTH,void *
  #else
    #define XOUTP_PARA_NON_LAST
    #define XOUTP_PARA_LAST
  #endif


  #ifdef XMK_USE_xOutEnv

    #if defined(XMK_USE_SIGNAL_PRIORITIES) && defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
      /*
      ** Each signal contains a Signal priority
      ** Each signal contains a Receiver PID
      */
      extern xmk_OPT_INT xOutEnv XPP(( xmk_T_SIGNAL,
                                         xmk_T_PRIO,
                                         XOUTP_PARA_NON_LAST
                                         xPID )) ;

    #endif

    #if defined(XMK_USE_SIGNAL_PRIORITIES) && !defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
      /*
      ** Each signal contains a Signal priority
      ** No   signal contains a Receiver PID
      */
      extern xmk_OPT_INT xOutEnv XPP(( xmk_T_SIGNAL,
                                         xmk_T_PRIO,
                                         XOUTP_PARA_LAST )) ;
    #endif

    #if !defined(XMK_USE_SIGNAL_PRIORITIES) && defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)
      /*
      ** No   signal contains a Signal priority
      ** Each signal contains a Receiver PID
      */
      extern xmk_OPT_INT xOutEnv XPP(( xmk_T_SIGNAL,
                                         XOUTP_PARA_NON_LAST
                                         xPID )) ;
    #endif


    #if !defined(XMK_USE_SIGNAL_PRIORITIES) && !defined(XMK_USE_RECEIVER_PID_IN_SIGNAL)

      #ifdef XMK_USED_SIGNAL_WITH_PARAMS
        /*
        ** No   signal contains a Signal priority
        ** No   signal contains a Receiver PID
        */
        extern xmk_OPT_INT xOutEnv XPP(( xmk_T_SIGNAL,
                                           XOUTP_PARA_LAST )) ;
      #else
        /*
        ** No   signal contains a Signal priority
        ** No   signal contains a Receiver PID
        */
        extern xmk_OPT_INT xOutEnv XPP(( xmk_T_SIGNAL ));
      #endif

    #endif

  #endif /* ...XMK_USE_xOutEnv */

  #undef  XOUTP_PARA_NON_LAST
  #undef  XOUTP_PARA_LAST


#endif /* ... !defined(SDTMT) && !defined(SDTGATE) */


/****+***************************************************************
228  _main
********************************************************************/
#if !defined(SDTMT) && !defined(SDTGATE)
  #include "mk_main.h"
#endif


/****+***************************************************************
229  Cmicro Tester
********************************************************************/
#ifdef XMK_ADD_MICRO_TESTER
#error  XMK_ADD_MICRO_TESTER_removed_by_GBU_990512
#else

  typedef struct
  {
    int                 max_allowed_entries;
    int                 max_counter;
    int                 howmany;
    long                address;
  }  xmk_T_CMD_QUERY_QUEUE_CNF;

  typedef struct
  {
    xmk_T_TIME          now;
    int                 max_allowed_entries;
    int                 max_counter;
    int                 howmany;
    long                address;
  }  xmk_T_CMD_QUERY_TIMER_CNF;

#endif /* ... XMK_ADD_MICRO_TESTER */


#ifdef XMK_ADD_SIGNAL_FILTER
  #define XMK_ALLOW_NO   0x00
  #define XMK_ALLOW_ALL  0xff
#endif


/*
** Definitions for trace into the RAM on target ...
*/
#ifdef XMK_ADD_TRACE_BUF
  /*
  ** subsection 228-8
  ** Trace into the RAM within the target system
  ** The information trade can be retrieved either
  **    * by using a emulator / debugger
  **    * or by using the Cmicro Tester Command CMD_TBUF_REQ / CMD_TBUF_CNF
  */

  /* Minimum of information to be traced into RAM */
  typedef struct {

    xmk_T_SIGNAL       signal   ;
    xPID               process  ;
    xmk_T_STATE        state    ;
    int                error    ;

  } xmk_TBF_ENTRY ;

#endif /* ... XMK_ADD_TRACE_BUF */

#if defined(XMK_ADD_MICRO_TESTER) && ! (defined(SDTMT) || defined(SDTGATE))
#error  IncludeFiles_removed_by_GBU_990512
#endif


/*
** file containing errors and their defines
*/
#include "ml_err.h"


/*
** Controlblock for ringbuffer trace in the memory (target)
*/
typedef struct {
  int            counter  ;        /* internal read/write counter  */
  int            buffersize     ;  /* buffersize                   */
  int            maximumentries ;  /* maximum amount of entries    */
  int            entrysize ;       /* size of one entry            */
  unsigned char  ctrl      ;       /* XMK_FIFO or XMK_RING         */
  char  xmk_RAM_ptr p_write ;      /* internal write pointer       */
  char  xmk_RAM_ptr p_read  ;      /* internal read pointer        */
  char  xmk_RAM_ptr p_buffer;      /* pointer to the ring buffer   */
} xmk_T_RING ;


#define XMK_OVERFLOW       -2      /* tag for ringbuffer full      */
#define XMK_FIFO           0       /* Use fifo a like control      */
#define XMK_RING           1       /* Use ringbuffer control       */

#include "ml_buf.h"



#if !defined(SDTMT) && !defined(SDTGATE)
  #ifdef XMK_ADD_MICRO_RECORDER
    #error  XMK_ADD_MICRO_RECORDER_removed_by_GBU_990512
  #endif
#endif

#ifdef XMK_ADD_MICRO_TESTER
  /*
  ** Data link functions to be provided by the user
  */
  extern void  xmk_DLInit   XPP((void));
  extern int   xmk_DLWrite  XPP((char xmk_RAM_ptr, int)) ;
  extern char* xmk_DLRead   XPP((void));
  extern void  xmk_DLDeinit XPP((void));
  extern void  xmk_DLQuery  XPP((void));
#endif

#if defined(XMK_ADD_STDIO)
  #define XMK_USE_MON         /* use Monitor functions, if not      */
                              /* already specified by printf        */
/*
GBU 990730  Removed since it is not used and causes depenencies.
*/
/*
  #include "ml_mon.h"
*/
#endif


#ifndef XMK_USE_NO_ERR_CHECK
extern int            xmk_GetChar           XPP (( void ));
#endif
#ifdef XMK_USE_OS_ENVIRONMENT
extern int            xmk_TermInit          XPP (( void ));
extern int            xmk_TermDeinit        XPP (( void ));
#endif
extern void xmk_RAM_ptr xAlloc              XPP ((xptrint));
extern void           xFree                 XPP ((void xmk_RAM_ptr xmk_RAM_ptr));

#if !(defined(SDTMT) || defined(SDTGATE)) && ( !defined(XNOUSEOFCHARSTRING) && !defined(XRESTUSEOFCHARSTRING) )
  extern SDL_Charstring xAlloc_SDL_Charstring XPP ((xptrint));
  extern void           xFree_SDL_Charstring  XPP ((void xmk_RAM_ptr xmk_RAM_ptr));
#endif

#if !(defined(SDTMT) || defined(SDTGATE)) && !defined(XNOUSEOFASN1)
  extern unsigned char * xAlloc_SDL_Bit_String XPP ((xptrint));
  extern void            xFree_SDL_Bit_String  XPP ((void xmk_RAM_ptr xmk_RAM_ptr));
#endif


/*
** The following is used to allocate memory for predefined sorts
*/
#define XFREEVARS
#define XXFREE xFree
#define XFREE(P,SIZE) xFree(P)
#define XXMALLOC xAlloc
#define XMALLOC(SIZE,REF_SORT) xAlloc(SIZE)



/*
** The following is used to allocate memory for sort "ref"
*/
#define XMALLOC(SIZE,REF_SORT) xAlloc(SIZE)

#ifdef XMK_ADD_MICRO_TESTER
  #error  XMK_ADD_MICRO_TESTER_removed_by_GBU_990512
#endif /* ... XMK_ADD_MICRO_TESTER */

extern void SDLTask XPP(( void ));

#ifdef SDLPRTST
  #error  SDLPRTST_removed_by_GBU_990512
#endif


#ifdef NO_GLOBAL_VARS
  #include "tls.h"
#endif /* NO_GLOBAL_VARS */

/* GBU and ONJ modification. 990201 */
/* AED, 000329: changed to unsigned char */
#undef xOr_SDL_Octet
#define xOr_SDL_Octet(B1,B2)    ((unsigned char)((B1)|(B2)))

#endif /* __ML_TYP_H_ */
