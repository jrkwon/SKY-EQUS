#ifndef LOG_H
#define LOG_H

/*===========================================================================

                      Log Services Header File

General Description
  This file contains declarations for packets to be logged.

Copyright (c) 1991-2000 by QUALCOMM, Inc.  All Rights Reserved.
===========================================================================*/

/*===========================================================================

                             Edit History

$Header:   O:/src/asw/COMMON/vcs/log.h_v   1.8.1.1   29 Mar 2001 17:32:34   ldefauw  $
   
when       who     what, where, why
--------   ---     ----------------------------------------------------------
12/05/00   lad     Added new logging API.  Packet defs moved to log_dmss.h
11/02/00   lad     Makeover + API enhancement and structure definition macros.
11/30/00   aaj     Mainlined FEATURE_MPEAK_LOGGING
11/20/00   jal     Merged GPS logging material back from 1.1.1.0 branch
11/10/00   jal     Larry reserved some log codes for Bluetooth.  Added the
                   comma he forgot.
11/06/00   ks      Added Full TDSO logging support.
11/10/00   aaj     Fixed energy sums in multipeak log structure
11/07/00   aaj     Added Paul's AGC to multipeak proc logs
11/07/00   aaj     Added extra temps for futuristic multipeak support
11/04/00   aaj     Fixed multipeak logging related bug
08/28/00   pj      Added support for GPS peak logging.
09/06/00   bgc     Added FEATURE_FACTORY_TESTMODE including a new log type
                   for CRC summaries.
08/31/00   lad     Added prototype for log_process_logmask().
08/07/00   br      Changes to log_ppm_db_data_type and log_ppm_srch_data_type,
                   Addition of GPS search peaks entry log type.  (Checkin: JL)
07/10/00   br      Changes to log_ppm_srch_data_type (Checkin: JL)
06/19/00   lad     Added Simple TDSO log record.  Updated QPCH and FFPC.
06/12/00   lad     Updated accumulation sizes to allow worst case generation
                   every 0.5 seconds.
06/08/00   br      Separated SRCH batch logging into SRCH batch, pilot phase
                   measurement search, and pilot phase measurement data base
                   logging.
06/06/00   lad     Updated QPCH logging format.
06/01/00   br      Pilot phase measurement results
05/31/00   jal     Removed GPS statistics type.  It's not going to be a log.
05/22/00   lad     Added QPCH and removed obsolete logs.
05/15/00   lad     Externalized log_nice[].  Added LOGMASK_NUM_BITS from diagi.h
05/10/00   lad     Added RLP statistics logging.
                   Trimmed sizees of IS2000 accumulated logs to save RAM.
04/20/00   lad     Updated and finalized IS2000 log record formats.
04/17/00   lad     Added Active Set/Ch Config log.  Changed headers to more
                   readable format for IS2000 logs. 
04/11/00   lad     Added log codes and packet definitions for Frame Types,
                   Service Configuration, Fwd/Rev Power Control, and 
                   SRCH/Finger info.
                   Removed LOG_CODE_TYPE_NUMITEMS and made log_status INLINE.
03/23/00   lad     Added RLP partial frames logging under FEATURE_RLP_LOGGING.
                   Removed forced size and PACKED qualifier for enum types.
02/28/00   lad     Made changes to use diagbuf allocation manager.
02/02/00   lad     Removed log definitions for logs that are generated by tools.
                   Added band class logging and EFS logging types. 
07/20/99   lad     Added walsh code definition to gen_ta_sup_ch.
09/17/99   lcc     Merged in PLT support from PLT archive:
           bgc     Updated number of log items for FEATURE_PLT
           bgc     Added in PLT logging
08/13/99    sk     Removed PACKED Keyword from Enums.
07/08/99    sk     Added a field to log_gen_ta_sup_ch_type for walsh code.
04/07/99    sk     Removed lint errors.
03/30/99   lad     Added support for FEATURE_IS95B_MDR and FEATURE_SPECIAL_MDR.
01/08/99   lad     Added FEATURE_PILOT_SCANNER support.
11/05/98   lad     Made necessary changes for ARM port.
04/13/98   dgy     Added general Temporal Analyzer packet, environment packet,
                   and type "A1" searcher pathlog packet. 
09/01/98   ajn     Added MAX_FINGS_MSM2x constants
04/08/97   tkr     Added diagnostic ver record. Changed the annotation log code
04/02/97   rdh     Added debug message log code as placeholder for future.
03/21/97   tkr     Changed data type in annotation record from byte to char
02/17/97   tkr     Added annotation record type
04/09/96   rdh     Modified searcher pathlog packet, creating type "B".
03/09/96   rdh     Added finely-sampled searcher pathlog packet, type "A".
01/24/95   gb      Fixed IS95 msg log types, now use CAI_LEN definitions.
08/23/95   gb      Fixed log_voc_type to account for 13k error mask logging.
08/18/95   jmk     Took out T_SP conditional compiling...
08/01/95   jmk     Added T_SP conditional compilation (exclude queue and protos)
05/03/95   rdh     Added log_status function.
04/13/95   rdh     Added sparsely-sampled AGC/pwr ctl log code type.
01/05/95   rdh     Added LOG_NOCEN_M for TC state DM TA centering control.
07/30/94   rdh     Increased LOG_TA2_CNT for IS-95 Phase III.
02/04/93   jai     Changed comment for log_ta packet.
10/06/92   jai     Added access channel info item and type.
10/05/92   arh     Added analog item and type
08/31/92   gb      DMSS ver.
03/05/91   rdb     Created first (uncommented) cut of file. Take over, Jen.
===========================================================================*/

#include "comdef.h"
#include "ts.h"

/* All MS generated logs will automatically OR LOG_BASE_C to the code.
*/
#define LOG_MS_EQUIP_ID  1 /* Mobile Station is assigned equipment ID 1. */

#define LOG_BASE_C  (LOG_MS_EQUIP_ID << 12)


/* Log Header Type
**   The following type defines the structure of the log entry header.
*/
typedef PACKED struct
{
  word   len;  /* Specifies the length, in bytes of 
                 the entry, including this header. */

  word   code; /* Specifies the log code for the 
                  entry as enumerated above.       
                  Note: This is specified as word 
                  to guarantee size.               */

  qword  ts;   /* The system timestamp for the log entry. The upper 48 bits
                  represent elapsed time since 6 Jan 1980 00:00:00 
                  in 1.25 ms units. The low order 16 bits represent elapsed 
                  time since the last 1.25 ms tick in 1/32 chip units 
                  (this 16 bit counter wraps at the value 49152).          */
}
log_hdr_type;


/*===========================================================================

MACRO LOG_RECORD_DEFINE
MACRO LOG_RECORD_END
      
DESCRIPTION
  These macros are used to define log record structures in the DMSS.  All 
  logging records use the same naming convention, which is handled by the 
  macro. 
  
  All log record types will be named as follows:
  
  LOG_xxx_C_type

   
===========================================================================*/
#define LOG_RECORD_DEFINE( xx_code )           \
  typedef struct xx_code##_tag xx_code##_type; \
  PACKED struct xx_code##_tag {                \
    log_hdr_type hdr; /* All logs must have a header */

#define LOG_RECORD_END };                       

#include "log_dmss.h"


/* Legacy definition of LOG_MAX_C is needed since some clients use it.
*/                     
#define LOG_MAX_C (LOG_LAST_C | LOG_BASE_C)

#define LOGMASK_NUM_BITS LOG_LAST_C

/*---------------------------------------------------------------------------
                       STATUS CODES FOR LOG SERVICES
---------------------------------------------------------------------------*/

typedef enum
{
  LOG_DONE_S = 0,  /* Function performed successfully.         */
  LOG_NOT_ENA_S,   /* Logging disabled for specified log code. */
  LOG_BUSY_S,      /* Logging of specified item in progress.   */
  LOG_BADP_S       /* Illegal parameter specified.             */
}log_ret_status_type;

/*---------------------------------------------------------------------------
                        LOG DESCRIPTOR TYPE
---------------------------------------------------------------------------*/

#if defined(FEATURE_DIAG_V7_LOG_COMPATIBILITY)
typedef struct
{
  q_link_type   link;
    /* Used in conjunction with the q_ptr field below for placing this
       descriptor onto a queue after it is processed. This field must be
       initialized by the caller prior to using the descriptor with the
       Log Services. */
  
  q_type        *q_ptr;
    /* Points to the queue on which to place this descriptor after it is
       processed. If NULL, then the descriptor is not placed on any queue.
       This field must be initialized by the caller prior to using the
       descriptor with the Log Services. It is not modified by the Log
       Services. */

  log_hdr_type  *log_ptr;
    /* Points to the header of the log buffer containing the data bytes
       to put in the log. This field must be initialized by the caller
       prior to using the Log Services. It is not modified by the Log
       Services. */
}
log_desc_type;
#endif /* defined(FEATURE_DIAG_V7_LOG_COMPATIBILITY) */


/*===========================================================================

                      FUNCTION DECLARATIONS

===========================================================================*/

/*===========================================================================

FUNCTION LOG_INIT

DESCRIPTION
  Initialize logging services.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS       
  If allocated buffers are held too long, it could stagnate the DIAG streaming 
  buffer, resulting in more dropped logs.  
  
  If you need to log accumulated data, store the accumulated data in your 
  own memory space and use log_submit() to log the data.
===========================================================================*/
void log_init( void );

/*===========================================================================

FUNCTION LOG_ALLOC

DESCRIPTION
  This function allocates a buffer of size 'length' for logging data.  The 
  specified length is the length of the entire log, including headers.  Since
  this allocation is made from a shared resource pool, log_commit must be called
  as soon as possible.  This operation is inteneded only for logs that do not
  require data accumulation.
  
  The following fields will be entered automatically into the log header:
  len  - the length of this log (given in argument list)
  code - the specified log code (given in argument list)
  ts   - timestamp.  Client does not need to enter timestamp information.
  

DEPENDENCIES
  log_commit() must be called as soon as data has been entered into the buffer.

RETURN VALUE
  A pointer to the allocated buffer is returned on success.
  If the log code is disabled or there is not enough space, NULL is returned.

SIDE EFFECTS       
  If allocated buffers are held too long, it could stagnate the DIAG streaming 
  buffer, resulting in more dropped logs.  
  
  If you need to log accumulated data, store the accumulated data in your 
  own memory space and use log_submit() to log the data.
===========================================================================*/
extern PACKED void * log_alloc_ex ( uint16       code,
                                    unsigned int length );

#define log_alloc(xx_code, xx_length) (xx_code##_type *) log_alloc_ex(xx_code, xx_length)

/*===========================================================================

FUNCTION LOG_SHORTEN

DESCRIPTION
  This function shortens the length of a previously allocated logging buffer.
  This is used when the size of the record is not known at allocation time.

DEPENDENCIES
  This must be called prior to log_commit().

RETURN VALUE
  Boolean indicating success of shorten operation.

SIDE EFFECTS       
  A hole is left in the DIAG output buffer until transmit time, resulting
  in a short-lived waste of output buffering RAM.
===========================================================================*/
extern void log_shorten ( PACKED void * log_ptr, 
                          unsigned int  length );

/*===========================================================================

FUNCTION LOG_COMMIT

DESCRIPTION
  This function commits a log buffer of the size indicated in the 'len' of the
  log_type passed in.
  Since this allocation is made from a shared resource pool, this must be 
  called as soon as possible after a log_alloc call.  This operation is not 
  intended for logs that take considerable amounts of time ( > 1 sec ).

DEPENDENCIES
  log_alloc must have been called prior to this.
  The pointer must be the same as the poitner given in a previous log_alloc() 
    call.

RETURN VALUE
  None.
  
SIDE EFFECTS
  None.

===========================================================================*/
extern void log_commit ( PACKED void *ptr );

/*===========================================================================

FUNCTION LOG_SUBMIT

DESCRIPTION
  This function is called to log an accumlated LOG item. If logging is
  enabled for the entry (using function log_config), then the entry
  is copied into the DIAG allocation manager and commited immediately.

  This function should be used in lieu of log_alloc() and log_commit()
  when log data needs to be accumlated.
  
DEPENDENCIES
  None.
  
RETURN VALUE
  Boolean indicating success.

SIDE EFFECTS
  None.
  
===========================================================================*/
extern boolean log_submit ( PACKED void *ptr );


/*===========================================================================

FUNCTION LOG_SET_TIMESTAMP

DESCRIPTION
  This function captures the system time and stores it in the given log record.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
  
===========================================================================*/
void log_set_timestamp( PACKED void *xx_log_ptr );


/*===========================================================================

FUNCTION LOG_SET_CODE

DESCRIPTION
  This function sets the logging code in the given log record.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
  
===========================================================================*/
#if defined TARGET_OS_SOLARIS || defined T_WINNT
#error code not present
#else

INLINE void log_set_code( PACKED void *xx_log_ptr, 
                          uint16       code ) 
{
    ((log_type *) xx_log_ptr)->hdr.code = code | LOG_BASE_C;

} /* log_set_code */

#endif /* TARGET_OS_SOLARIS || T_WINNT */

/*===========================================================================

FUNCTION LOG_SET_LENGTH

DESCRIPTION
  This function sets the length field in the given log record.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  None.
  
===========================================================================*/
#ifndef NO_INLINE

INLINE void log_set_length( PACKED void *xx_log_ptr, 
                            unsigned int length ) 
{
    ((log_type *) xx_log_ptr)->hdr.len = (uint16) length;

} /* log_set_length */

#else
#error code not present
#endif /* NO_INLINE */

#if defined(FEATURE_DIAG_V7_LOG_COMPATIBILITY)
/*===========================================================================

FUNCTION LOG_PUT

DESCRIPTION
  This function is called to log a specified log entry. If logging is
  enabled for the entry (using function log_config), then the entry
  is placed onto the diagbuf buffer where it will be read by the diagnostic
  task and sent to the external device for actual storage.  Afterwards,
  the buffer used to hold the entry is returned to a specified queue.

  If logging for the entry is not enabled, then the entry buffer is
  immediately returned to the specified queue.

DEPENDENCIES
  Prior to calling this function, function log_config should be called to
  select which type of log entries to log. Also, the diagbuf allocation
  manager must be initialized (diagbuf_init()) prior to calling this function.

RETURN VALUE
  None.
  
SIDE EFFECTS
  Specified item is logged, spent log entry buffer is returned to specified
  queue.
===========================================================================*/
extern void  log_put ( log_desc_type  *desc_ptr );
#endif


/*===========================================================================

FUNCTION LOG_CONFIG

DESCRIPTION
  This function selects which log codes are enabled for logging.

DEPENDENCIES
  None.

RETURN VALUE
  LOG_DONE_S, if log code successfully enabled/disabled. 
  LOG_BADP_S, if invalid log code specified.

SIDE EFFECTS
  Affects what type of entries are logged.
===========================================================================*/
extern word log_config ( word  code, boolean  flag );


/*===========================================================================

FUNCTION LOG_PROCESS_LOGMASK

DESCRIPTION
  This function sets the logmask from the logmask bit field specified in the
  diag_ext_logmask_req_type packet.

DEPENDENCIES
  None.

RETURN VALUE
  None.

SIDE EFFECTS
  Affects what type of entries are logged.
===========================================================================*/
extern void log_process_logmask (PACKED uint8 *logmask_ptr, int num_bits );

/*===========================================================================

FUNCTION LOG_STATUS

DESCRIPTION
  This function returns whether a particular code is enabled for logging.

===========================================================================*/
boolean  log_status ( word  code ) ;
#endif /* LOG_H */

